#!/usr/bin/env perl -w
#
# Plots (using gnuplot) some curves from Dave's transaction based metrics
# generated by his /work/ring/mc/bin/fpMetrics tool.
#
# The layout of the fpMetrics is as following
#
# Column 1:  Score threshold
#
# Transaction-weighted metrics:
# Column 2:  False-positive ratio
# Column 3:  Percent outsort
# Column 4:  Percent nonfraud
# Column 5:  Percent fraud
# Column 6:  Percent approved fraud
# Column 7:  Real-time VDR
# Column 8:  Online VDR
#
# Dollar-weighted metrics:
# Column 9:  False-positive ratio
# Column 10: Percent outsort
# Column 11: Percent nonfraud
# Column 12: Percent fraud
# Column 13: Percent approved fraud
# Column 14: Real-time VDR
# Column 15: Online VDR
# 
# Output is:
#   (a) to the screen (always)
#   (b) to postscript file (user queried)
#   (c) to cgm (MS-Word readable) file (user queried)
#
# Postscript curves from different runs should be of the same scale ---
# hold them up to the light and see the curves on the same scales.
#
# More detailed usage below (to see, execute without any command line
# args).

# This tool is based on Paul's plot_RES
#
# $Log: plot_fpMetrics.pl,v $
# Revision 1.2  2006/06/21 21:54:41  dxl
# clean up unnecessary options from plot_RES, such as '-d'.
#
# Revision 1.1  2006/06/21 20:39:11  dxl
# Initial revision
#

$rcsID='$Id: plot_fpMetrics.pl,v 1.2 2006/06/21 21:54:41 dxl Exp dxl $';

@GRAPH = (
   { xaxis => "nonfraud",       yaxis => "fraud"          },
   { xaxis => "nonfraud",       yaxis => "afraud"         },
   { xaxis => "dnonfraud",      yaxis => "dfraud"         },
   { xaxis => "dnonfraud",      yaxis => "dafraud"        },
   { xaxis => "dnonfraud",      yaxis => "drtvdr"         },
   { xaxis => "nonfraud",       yaxis => "dolvdr"         },
   { xaxis => "nonfraud",       yaxis => "dnonfraud"      },
   { xaxis => "score",          yaxis => "nonfraud"       },
   { xaxis => "score",          yaxis => "dnonfraud"      },
   { xaxis => "score",          yaxis => "outsort"        },
   { xaxis => "score",          yaxis => "doutsort"       },
   { xaxis => "score",          yaxis => "fraud"          },
   { xaxis => "score",          yaxis => "afraud"         },
   { xaxis => "score",          yaxis => "rttdr"          },
   { xaxis => "score",          yaxis => "oltdr"          },
   { xaxis => "score",          yaxis => "dtfpr"          },
   { xaxis => "score",          yaxis => "dfraud"         },
   { xaxis => "score",          yaxis => "drtvdr"         },
   { xaxis => "score",          yaxis => "dolvdr"         },
   { xaxis => "tfpr",           yaxis => "outsort"        },
   { xaxis => "tfpr",           yaxis => "drtvdr"         },
   { xaxis => "tfpr",           yaxis => "dolvdr"         },
   { xaxis => "tfpr",           yaxis => "rttdr"          },
   { xaxis => "tfpr",           yaxis => "oltdr"          },
   { xaxis => "dtfpr",          yaxis => "doutsort"       },
   { xaxis => "dtfpr",          yaxis => "drtvdr"         },
   { xaxis => "dtfpr",          yaxis => "dolvdr"         },
   { xaxis => "dtfpr",          yaxis => "rttdr"          },
   { xaxis => "dtfpr",          yaxis => "oltdr"          },
);

# default graphs
@IMP = (0, 1, 2, 3, 4, 5);

########################################
# 
# Define where in the data file you will find each of the above items.
#
# This must change if your data file output changes!!!!!

%COL = (
   "score"          => 1,
   "tfpr"           => 2,
   "outsort"        => 3,
   "nonfraud"       => 4,
   "fraud"          => 5,
   "afraud"         => 6,
   "rttdr"          => 7,
   "oltdr"          => 8,
   "dtfpr"          => 9,
   "doutsort"       => 10,
   "dnonfraud"      => 11,
   "dfraud"         => 12,
   "dafraud"        => 13,
   "drtvdr"         => 14,
   "dolvdr"         => 15,
);

########################################
# 
# Define a label which described each of the above items

%LABEL = (
   "score"          => "Score",
   "tfpr"           => "Transaction False Positive Ratio",
   "outsort"        => "Overall Score Distribution",
   "nonfraud"       => "Percent Nonfraud Transactions",
   "fraud"          => "Percent Fraud Transactions",
   "afraud"         => "Percent Approved Fraud Transactions",
   "rttdr"          => "Real-Time Transaction Detection Rate",
   "oltdr"          => "On-Line Transaction Detection Rate",
   "dtfpr"          => "Dollar-weighted Transaction False Positive Ratio",
   "doutsort"       => "Dollar-weighted Overall Score Distribution",
   "dnonfraud"      => "Dollar-weighted Percent Nonfraud Transactions",
   "dfraud"         => "Dollar-weighted Percent Fraud Transactions",
   "dafraud"        => "Dollar-weighted Percent Approved Fraud Transactions",
   "drtvdr"         => "Real-Time Value Detection Rate",
   "dolvdr"         => "On-Line Value Detection Rate",
);

########################################
# 
# Define a range for each of the above items

%RANGE = (

   "score"          => "[500:1000]",
   "tfpr"           => "[0:100]",
   "outsort"        => "[0:2]",
   "nonfraud"       => "[0:2]",
   "fraud"          => "[0:100]",
   "afraud"         => "[0:100]",
   "rttdr"          => "[0:100]",
   "oltdr"          => "[0:100]",
   "dtfpr"          => "[0:100]",
   "doutsort"       => "[0:10]",
   "dnonfraud"      => "[0:10]",
   "dfraud"         => "[0:100]",
   "dafraud"        => "[0:100]",
   "drtvdr"         => "[0:100]",
   "dolvdr"         => "[0:100]",

);

########################################
# 
# Define the key location for each of the above items when it is the x-axis

%KEY_LOCATION = (

   "score"          => "top right",
   "tfpr"           => "bottom right",
   "outsort"        => "bottom right",
   "nonfraud"       => "bottom right",
   "fraud"          => "bottom right",
   "afraud"         => "bottom right",
   "rttdr"          => "bottom right",
   "oltdr"          => "bottom right",
   "dtfpr"          => "bottom right",
   "doutsort"       => "bottom right",
   "dnonfraud"      => "bottom right",
   "dfraud"         => "bottom right",
   "dafraud"        => "bottom right",
   "drtvdr"         => "bottom right",
   "dolvdr"         => "bottom right",

);
$clear_key = 0;

########################################
# 
# Defaults and them options...

@GRAPH_CHOICE = ();
$STYLE="linespoints";
$HELP="N";
$YRANGE="";
$XRANGE="";
$TITLE=" ";
$KEY="";
$QUIET = 1;
$ANSWER_CGM = "n";
$ANSWER_PS = "n";
$ANSWER_PS_COLOR = "n";
$DO_ALL = 0;

while ( (scalar @ARGV) > 0 ) {
   $i=shift @ARGV;
   if ( "$i" eq "-h" ) {
      $HELP="Y";
   } elsif ( $i =~ m/^\-([0-9]+)$/ ) {
      push @GRAPH_CHOICE, $1 - 1;
   } elsif ( "$i" eq "-nl" ) {
      $STYLE="points";
   } elsif ( "$i" eq "-np" ) {
      $STYLE="lines";
   } elsif ( "$i" eq "-ur" ) {
      $KEY="$KEY top right"
   } elsif ( "$i" eq "-br" ) {
      $KEY="$KEY bottom right";
   } elsif ( "$i" eq "-s" ) {
      $XRANGE="[ * : * ]";
      $YRANGE="[ * : * ]";
   } elsif ( "$i" eq "-v" ) {
      $QUIET = 0;
   } elsif ( "$i" eq "-q" ) {
      $QUIET = 1;
   } elsif ( "$i" eq "-Q" ) {
      $QUIET = 2;
   } elsif ( "$i" eq "-c" ) {
      $ANSWER_CGM = "y";
   } elsif ( "$i" eq "-P" ) {
      $ANSWER_PS_COLOR = "y";
   } elsif ( "$i" eq "-p" ) {
      $ANSWER_PS = "y";
   } elsif ( "$i" eq "-xr" ) {
      $j = shift @ARGV;
      $XRANGE=$j;
   } elsif ( "$i" eq "-yr" ) {
      $j = shift @ARGV;
      $YRANGE=$j;
   } elsif ( "$i" eq "-title" ) {
      $j = shift @ARGV;
      $TITLE=$j;
   } elsif ( "$i" eq "-all" ) {
      $DO_ALL = 1;
   } elsif ( "$i" eq "-imp" ) {
      push @GRAPH_CHOICE, @IMP;
   } else {
       if ( -r $i ) {
           push @FILES, $i;
       } else {
           print "Could not open $i\n";
           exit(2);
       }
   }
}



########################################

if ( !"@FILES" || $HELP eq "Y" ) {
   print "No files found on the command line!

Usage:  $0 \\
             [-[1-29]] [-np] [-nl] \\
             [-v] [-q] [-Q] [-P] [-p] [-c] \\
             [-s] [-ur] [-br] [-xr <range>] \\
             [-all] [-imp] \\
             [-d] \\
             [-yr <range> ] <file-1> [ <file-2> [...] ]


 The default curves are (with no number specified):\n";
  foreach $i (@IMP) {
  printf "   %s vs. %s\n",
   $LABEL{$GRAPH[$i]{xaxis}},$LABEL{$GRAPH[$i]{yaxis}};
  }
 
  print "
 Output is:
   (a) to the screen (always)
   (b) to postscript file (user queried)
   (c) to cgm (MS-Word readable) file (user queried)

 Postscript curves from different runs should be of the same scale ---
 hold them up to the light and see the curves on the same scales.

 Author: dxl 06/20/2006
 This tool is based on Paul's plot_RES


$rcsID


 -v          Verbose.  Annoy the user as much as possible.
 -q          Quiet.  Do not ask user anything. (default)
 -Q          Quiet!  Don't even display the graph!
 -p          Automatically put out postcript.
 -P          Automatically put out Color postcript.
 -c          Automatically put out cgm.
 -np         Do not put individul points on the graph
 -nl         Do not put lines on the graph
 -s          Autoscale both axes
 -ur         Legend in the upper right
 -br         Legend in the bottom right
 -xr <range> Use <range> as the x-axis range
 -yr <range> Use <range> as the y-axis range
             <range> = [<lo>:<hi>], and needs to be quoted in most shells
 -title <t>  Use <t> as the graph title (quote as needed for your shell).
 -all        Plot all curves.
\n";

   for ($i = 0; $i< scalar(@GRAPH) ; $i++) {
      printf " -%-2d  Plot %s vs %s\n", $i+1,
         $LABEL{$GRAPH[$i]{xaxis}}, $LABEL{$GRAPH[$i]{yaxis}};
   }

   print "\n";

   exit(3);
}



########################################

if (!$QUIET) {
   print "\n\nPlease input the graph title : ";
   $NEWTITLE = <STDIN>;
   chop $NEWTITLE;

   if ($NEWTITLE) {
      $TITLE="$NEWTITLE ";
   }
}

########################################

if ($DO_ALL) {
    for ($i = scalar (@GRAPH) - 1; $i >= 0; $i--) {
        &doPlot($i);
        sleep 1;
    }
} else {
    if (scalar (@GRAPH_CHOICE) == 0) {
        push @GRAPH_CHOICE, @IMP;
    }
    #print "GRAPH_CHOICE =  @GRAPH_CHOICE\n";

    for ($i = scalar (@GRAPH_CHOICE) - 1; $i >= 0; $i--) {
        &doPlot($GRAPH_CHOICE[$i]);
        sleep 1;
    }
}
exit(0);


################################################################################

sub doPlot {
   
   if ( -x "/usr/bin/env gnuplot" ) {
       $GNUPLOT = "| /usr/bin/env gnuplot -persist";
   } elsif ( -x "/usr/bin/gnuplot" ) {
       $GNUPLOT = "| /usr/bin/gnuplot -persist";
   }
   open GNUPLOT or die "Could not open $GNUPLOT!\n";
   select GNUPLOT; $| = 1;
   select STDOUT;

   my ($CHOICE) = @_;
########################################


    $X=$GRAPH[$CHOICE]{'xaxis'};
    $Y=$GRAPH[$CHOICE]{'yaxis'};

    $XCOL=$COL{$X};
    $XLABEL=$LABEL{$X};
    if (! $XRANGE) {
        $XR = $RANGE{$X};
    } else {
        $XR = $XRANGE;
    }


    $YCOL=$COL{$Y};
    $YLABEL=$LABEL{$Y};
    if (! $YRANGE) {
        $YR = $RANGE{$Y};
    } else {
        $YR = $YRANGE;
    }

    if (! $KEY) {
        $KEY = $KEY_LOCATION {$X};
        $clear_key = 1;
    }

########################################

    print GNUPLOT "set grid\n";
    print GNUPLOT "set data style $STYLE\n";
    print GNUPLOT "set xrange $XR\n";
    print GNUPLOT "set yrange $YR\n";
    print GNUPLOT "set xlabel '$XLABEL'\n";
    print GNUPLOT "set ylabel '$YLABEL'\n";
    print GNUPLOT "set title \"$TITLE\"\n";
    print GNUPLOT "set timestamp\n";
    print GNUPLOT "set key $KEY\n";
    if ($QUIET > 1) {
        print GNUPLOT "set term dumb\n";
        print GNUPLOT "set out '/dev/null'\n";
    }
    print GNUPLOT "plot \\\n";
    #$NUM=0;
    $FIRST=1;
    foreach $i (@FILES) {
        if ($FIRST) {
            $FIRST=0;
        } else {
            print GNUPLOT ", \\\n";
        }
        print GNUPLOT
            "'$i' using $XCOL:$YCOL title '$i'";
        #$NUM++;
    }
    print GNUPLOT "\n";



########################################

    $C = sprintf "%3.3d", $CHOICE + 1;

    if (!$QUIET) {
        print "Do you desire a postscript output? [n] : ";
        $ANSWER_PS = <STDIN>;
    }
    if ( $ANSWER_PS  =~ /^y/ || $ANSWER_PS  =~ /^Y/ ) {
        print GNUPLOT "set terminal postscript\n";
        print GNUPLOT "set out 'plot_RES.$C.$Y.$X.$$.ps'\n";
        print GNUPLOT "replot\n";

        print "\n";
        print "Postscript output to plot_RES.$C.$Y.$X.$$.ps\n";
        print "\n";
    }

    if (!$QUIET) {
        print "Do you desire a color postscript output? [n] : ";
        $ANSWER_PS_COLOR = <STDIN>;
    }
    if ( $ANSWER_PS_COLOR  =~ /^y/ || $ANSWER_PS_COLOR  =~ /^Y/ ) {
        print GNUPLOT "set terminal postscript color\n";
        print GNUPLOT "set out 'plot_RES.$C.$Y.$X.$$.color.ps'\n";
        print GNUPLOT "replot\n";

        print "\n";
        print "Postscript output to plot_RES.$C.$Y.$X.$$.color.ps\n";
        print "\n";
    }



########################################

    if (!$QUIET) {
        print "Do you desire a cgm (MS-Word readable) output? [n] : ";
        $ANSWER_CGM = <STDIN>;
    }
    if ( $ANSWER_CGM =~ /^y/ || $ANSWER_CGM =~ /^Y/ ) {
        # print GNUPLOT "set terminal cgm\n";
        print GNUPLOT "set key $KEY Left reverse width 3.0 spacing 1.5\n";
        print GNUPLOT "set terminal cgm 'Times Roman'\n";
        print GNUPLOT "set out 'plot_RES.$C.$Y.$X.$$.cgm'\n";
        print GNUPLOT "replot\n";

        print "";
        print "CGM output to plot_RES.$C.$Y.$X.$$.cgm\n";
        print "\n";
    }


########################################

    close GNUPLOT;

# $sys_return=system ("/usr/bin/env gnuplot -persist < gnuplot.$$");

    if ($? != 0) {
        print "gnuplot returned $?\n";
    }

    $KEY="" if ($clear_key);


}
## print quiting time... ; read ANSWER


# vim:tw=78:
