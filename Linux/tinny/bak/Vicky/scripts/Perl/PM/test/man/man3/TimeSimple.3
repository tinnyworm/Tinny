.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Time::Simple 3"
.TH Time::Simple 3 "2006-08-03" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
Time::Simple \- A simple, light\-weight ISO 8601 time object.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        use Time::Simple;
\&        my $time   = Time::Simple->new('23:24:59');
\&        my $hour   = $time->hours;
\&        my $minute = $time->minutes;
\&        my $second = $time->seconds;
.Ve
.PP
.Vb 1
\&        my $time2  = Time::Simple->new($hour, $minute, $second);
.Ve
.PP
.Vb 3
\&        my $now = Time::Simple->new;
\&        my $nexthour = $now + 60;
\&        print "An hour from now is $nexthour.\en";
.Ve
.PP
.Vb 3
\&        if ($nexthour->hour > 23) {
\&                print "It'll be tomorrow within the next hour!\en";
\&        }
.Ve
.PP
.Vb 4
\&        # You can also do this:
\&        ($time cmp "23:24:25")
\&        # ...and this:
\&        ($time <=> [23, 24, 25])
.Ve
.PP
.Vb 2
\&        $time++; # Add a second
\&        $time--; # Subtract a second
.Ve
.PP
.Vb 3
\&        # Seconds of difference:
\&        $seconds = Time::Simple->new("00:00:02")
\&                 - Time::Simple->new("00:00:01");
.Ve
.PP
.Vb 5
\&        my $now  = Time::Simple->new;
\&        # A minute from now:
\&        my $then = Time::Simple->new( $now + 60 );
\&        # Or:
\&        my $soon = Time::Simple->new( '00:01:00' );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A simple, light-weight time object.
.PP
\&\fBThis version should be considered an alpha developer release\fR.
.PP
How do you think this moudle should handle return values of multiplacation, where the
return value would be greater than 23:59:59?
.SH "FATAL ERRORS"
.IX Header "FATAL ERRORS"
Attempting to create an invalid time with this module will return \f(CW\*(C`undef\*(C'\fR rather than an object.
.PP
Some operations can produce fatal errors: these can be replaced by warnings and the
return of \f(CW\*(C`undef\*(C'\fR by switching the value of \f(CW$FATALS\fR:
.PP
.Vb 1
\&        $Time::Simple::FATALS = undef;
.Ve
.PP
You will then only get warnings to \f(CW\*(C`STDERR\*(C'\fR, and even then only if you asked perl for
warnings with \f(CW\*(C`use warnings\*(C'\fR or by setting \f(CW$^W\fR either directly or with the \f(CW\*(C`\-w\*(C'\fR
command-line switch.
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.Sh "\s-1CONSTRUCTOR\s0 (new)"
.IX Subsection "CONSTRUCTOR (new)"
.Vb 3
\&    $_ = Time::Simple->new('21:10:09');
\&    $_ = Time::Simple->new( 11,10, 9 );
\&    $_ = Time::Simple->new( time() );
.Ve
.PP
The constructor \f(CW\*(C`new\*(C'\fR returns a \f(CW\*(C`Time::Simple\*(C'\fR object if the supplied
values specify a valid time, otherwise returns \f(CW\*(C`undef\*(C'\fR.
.PP
Valid times are either as supplied by the time, or in \s-1ISO\s0 8601
format. In the latter case, the values may be supplied as a colon-delimited scalar,
as a list, or as an anonymous array.
.PP
If nothing is supplied to the constructor, the current local time will be used.
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.Sh "\s-1METHOD\s0 next"
.IX Subsection "METHOD next"
.Vb 1
\&    my $will_be_by_one_second = $now->next;
.Ve
.PP
Returns the next time by incrementing the caller's time by one second.
.Sh "\s-1METHOD\s0 prev"
.IX Subsection "METHOD prev"
.Vb 1
\&    my $was_by_one_second = $now->prev;
.Ve
.PP
Returns the last time by decrementing the caller's time by one second.
.Sh "\s-1METHOD\s0 hour"
.IX Subsection "METHOD hour"
.Vb 1
\&    my $hr = $time->hour;
.Ve
.PP
The hour. Alias: \f(CW\*(C`hours\*(C'\fR.
.Sh "\s-1METHOD\s0 minute"
.IX Subsection "METHOD minute"
.Vb 1
\&    my $min = $time->minute;
.Ve
.PP
The minutes. Alias: \f(CW\*(C`minutes\*(C'\fR.
.Sh "\s-1METHOD\s0 second"
.IX Subsection "METHOD second"
.Vb 1
\&    my $sec = $time->second;
.Ve
.PP
The seconds. Alias: \f(CW\*(C`seconds\*(C'\fR.
.Sh "format"
.IX Subsection "format"
Returns a string representing the time, in the format specified.
If you don't pass a parameter, an \s-1ISO\s0 8601 formatted time is returned.
.PP
.Vb 3
\&    $date->format;
\&    $date->format("%H hours, %M minutes, and %S seconds");
\&    $date->format("%H-%M-%S");
.Ve
.PP
The formatting parameter is as you would pass to \f(CWstrftime(3)\fR:
\&\*(L"strftime\*(R" in \s-1POSIX\s0.
.SH "OPERATORS"
.IX Header "OPERATORS"
Some operators can be used with \f(CW\*(C`Time::Simple\*(C'\fR objects:
.IP "+= \-=" 4
You can increment or decrement a time by a number of seconds using the
\&\f(CW\*(C`+=\*(C'\fR and \f(CW\*(C`\-=\*(C'\fR operators
.IP "+ \-" 4
You can construct new times offset by a number of seconds using the
\&\f(CW\*(C`+\*(C'\fR and \f(CW\*(C`\-\*(C'\fR operators.
.IP "\-" 4
You can subtract two times (\f(CW\*(C`$t1 \- $t2\*(C'\fR) to find the number of seconds between them.
.IP "comparison" 4
.IX Item "comparison"
You can compare two times using the arithmetic and/or string comparison operators:
\&\f(CW\*(C`lt le ge gt < <= >= >\*(C'\fR.
.ie n .IP """""" 4
.el .IP "``''" 4
You can interpolate a time instance directly into a string, in the format
specified by \s-1ISO\s0 8601 (eg: 23:24:25).
.IP "*" 4
You can multiply a time by a number: \f(CW\*(C`00:00:30 * 2 = 00:01:00\*(C'\fR.
.IP "/" 4
You can divide a time by a number: \f(CW\*(C`00:02:00 * 2 = 00:01:00\*(C'\fR.
.Sh "\s-1DIAGNOSTICS\s0"
.IX Subsection "DIAGNOSTICS"
.RE
.ie n .IP """Illegal octal digit ...."""
.el .IP "\f(CWIllegal octal digit ....\fR"
.IX Item "Illegal octal digit ...."
You probably used an anonymous array and prefixed a number with a leading zero, as you would
if you supplied a scalar string: \f(CW\*(C`[11,10,09]\*(C'\fR.
.SH "TODO"
.IX Header "TODO"
Suggestions welcome. How should operators not mentioend behave? Can one \f(CW\*(C`verbar\*(C'\fR times?
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Time::HiRes, Date::Time,
Date::Simple,
\&\*(L"localtime\*(R" in perlfunc,
\&\*(L"time\*(R" in perlfunc.
\&\*(L"strftime\*(R" in \s-1POSIX\s0, \*(L"mktime\*(R" in \s-1POSIX\s0.
.SH "LATEST CHANGES"
.IX Header "LATEST CHANGES"
Version 0.05 Sun 02 July 16:52 2006 \- Added multiply and division
.SH "CREDITS"
.IX Header "CREDITS"
This module is a rewrite of Marty Pauley's excellent and very useful \f(CW\*(C`Date::Simple\*(C'\fR
object. If you're reading, Marty: many thanks. For support, though, please contact
Lee Goddard (lgoddard \-at\- cpan \-dot\- org) or use rt.cpan.org.
.PP
Thanks to Zsolt for testing.
.SH "AUTHOR"
.IX Header "AUTHOR"
Lee Goddard (lgoddard \-at\- cpan \-dot\- org) after Marty Pauley.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006 Lee Goddard. Parts Copyright (C) 2001, \fIKasei\fR.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either:
a) the \s-1GNU\s0 General Public License;
 either version 2 of the License, or (at your option) any later version.
b) the Perl Artistic License.
.PP
This program is distributed in the hope that it will be useful, but
\&\s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0
or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
