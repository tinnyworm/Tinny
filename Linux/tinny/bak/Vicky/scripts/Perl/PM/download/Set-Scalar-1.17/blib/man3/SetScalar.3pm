.\" Automatically generated by Pod::Man version 1.02
.\" Mon Aug 25 20:14:34 2003
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Set::Scalar 3"
.TH Set::Scalar 3 "perl v5.6.0" "2001-12-07" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Set::Scalar \- basic set operations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use Set::Scalar;
\&    $s = Set::Scalar->new;
\&    $s->insert('a', 'b');
\&    $s->delete('b');
\&    $t = Set::Scalar->new('x', 'y', $z);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Creating"
.IX Subsection "Creating"
.Vb 2
\&    $s = Set::Scalar->new;
\&    $s = Set::Scalar->new(@members);
.Ve
.Vb 2
\&    $t = $s->clone;
\&    $t = $s->copy; # clone of clone
.Ve
.Sh "Modifying"
.IX Subsection "Modifying"
.Vb 3
\&    $s->insert(@members);
\&    $s->delete(@members);
\&    $s->invert(@members); # insert if hasn't, delete if has
.Ve
.Vb 1
\&    $s->clear; # removes all the elements
.Ve
Note that \fIclear()\fR only releases the memory used by the set to
be reused by Perl; it will not reduce the overall memory use.
.Sh "Displaying"
.IX Subsection "Displaying"
.Vb 1
\&    print $s, "\en";
.Ve
The display format of a set is the members of the set separated by
spaces and enclosed in parentheses ().
.PP
You can even display recursive sets.
.PP
See the Customising Display entry elsewhere in this document for customising the set display.
.Sh "Querying"
.IX Subsection "Querying"
.Vb 2
\&    @members  = $s->members;
\&    @elements = $s->elements; # alias for members
.Ve
.Vb 1
\&    $size = $s->size; # the number of members
.Ve
.Vb 2
\&    $s->has($m)       # return true if has that member
\&    $s->contains($m)  # alias for has
.Ve
.Vb 1
\&    if ($s->has($member)) { ... }
.Ve
.Vb 2
\&    $s->member($m)    # returns the member if has that member
\&    $s->element($m)   # alias for member
.Ve
.Vb 3
\&    $s->is_null       # returns true if the set is empty
\&    $s->is_empty      # alias for is_null
\&    $s->is_universal  # returns true if the set is universal
.Ve
.Vb 3
\&    $s->null          # the null set
\&    $s->empty         # alias for null
\&    $s->universe      # the universe of the set
.Ve
.Sh "Deriving"
.IX Subsection "Deriving"
.Vb 6
\&    $u = $s->union($t);
\&    $i = $s->intersection($t);
\&    $d = $s->difference($t);
\&    $e = $s->symmetric_difference($t);
\&    $v = $s->unique($t);
\&    $c = $s->complement;
.Ve
These methods have operator overloads:    
.PP
.Vb 6
\&    $u = $s + $t; # union
\&    $i = $s * $t; # intersection
\&    $d = $s - $t; # difference
\&    $e = $s % $t; # symmetric_difference
\&    $v = $s / $t; # unique
\&    $c = -$s;     # complement
.Ve
Both the \f(CW\*(C`symmetric_difference\*(C'\fR and \f(CW\*(C`unique\*(C'\fR are symmetric on all
their arguments.  For two sets they are identical but for more than
two sets beware: \f(CW\*(C`symmetric_difference\*(C'\fR returns true for elements
that are in an odd number (1, 3, 5, ...) of sets, \f(CW\*(C`unique\*(C'\fR returns
true for elements that are in one set.
.PP
Some examples of the various set differences:
.PP
.Vb 1
\&    set or difference                   value
.Ve
.Vb 3
\&    $a                                  (a b c d e)
\&    $b                                  (c d e f g)
\&    $c                                  (e f g h i)
.Ve
.Vb 3
\&    $a->difference($b)                  (a b)
\&    $a->symmetric_difference($b)        (a b f g)
\&    $a->unique($b)                      (a b f g)
.Ve
.Vb 3
\&    $b->difference($a)                  (f g)
\&    $b->symmetric_difference($a)        (a b f g)
\&    $b->unique($a)                      (a b f g)
.Ve
.Vb 3
\&    $a->difference($b, $c)              (a b)
\&    $a->symmetric_difference($b, $c)    (a b e h i)
\&    $a->unique($b, $c)                  (a b h i)
.Ve
.Sh "Comparing"
.IX Subsection "Comparing"
.Vb 7
\&    $eq = $s->is_equal($t);
\&    $dj = $s->is_disjoint($t);
\&    $pi = $s->is_properly_intersecting($t);
\&    $ps = $s->is_proper_subset($t);
\&    $pS = $s->is_proper_superset($t);
\&    $is = $s->is_subset($t);
\&    $iS = $s->is_superset($t);
.Ve
.Vb 1
\&    $cmp = $s->compare($t);
.Ve
The \f(CW\*(C`compare\*(C'\fR method returns a string from the following list:
\&\*(L"equal\*(R", \*(L"disjoint\*(R", \*(L"proper subset\*(R", \*(L"proper superset\*(R", \*(L"proper
intersect\*(R", and in future (once I get around implementing it),
\&\*(L"disjoint universes\*(R".
.PP
These methods have operator overloads:    
.PP
.Vb 7
\&    $eq = $s == $t; # is_equal
\&    $dj = $s != $t; # is_disjoint
\&    # No operator overload for is_properly_intersecting.
\&    $ps = $s < $t;  # is_proper_subset
\&    $pS = $s > $t;  # is_proper_superset
\&    $is = $s <= $t; # is_subset
\&    $iS = $s >= $t; # is_superset
.Ve
.Vb 1
\&    $cmp = $s <=> $t;
.Ve
.Sh "Boolean contexts"
.IX Subsection "Boolean contexts"
In Boolean contexts such as
.PP
.Vb 2
\&    if ($set) { ... }
\&    while ($set1 && $set2) { ... }
.Ve
the size of the \f(CW\*(C`$set\*(C'\fR is tested, so empty sets test as false,
and non-empty sets as true.
.Sh "Iterating"
.IX Subsection "Iterating"
.Vb 1
\&    while (defined(my $e = $s->each)) { ... }
.Ve
This is more memory-friendly than
.PP
.Vb 1
\&    for my $e ($s->elements) { ... }
.Ve
which would first construct the full list of elements and then
walk through it: the \f(CW\*(C`$s\->each\*(C'\fR handles one element at a time.
.PP
Analogously to using normal \f(CW\*(C`each(%hash)\*(C'\fR in scalar context,
using \f(CW\*(C`$s\->each\*(C'\fR has the following caveats:
.Ip "\(bu" 4
The elements are returned in (apparently) random order.
So don't expect any particular order.
.Ip "\(bu" 4
When no more elements remain \f(CW\*(C`undef\*(C'\fR is returned.  Since you may one
day have elements named \f(CW\*(C`0\*(C'\fR don't test just like this
.Sp
.Vb 1
\&    while (my $e = $s->each) { ... }          # WRONG
.Ve
but instead like this
.Sp
.Vb 1
\&    while (defined(my $e = $s->each)) { ... } # right
.Ve
.Ip "\(bu" 4
There is one iterator per one set which is shared by many
element-accessing interfaces\-\- using the following will reset the
iterator: \fIelements()\fR, \fIinsert()\fR, \fImembers()\fR, \fIsize()\fR, \fIunique()\fR.  \fIinsert()\fR
causes the iterator of the set being inserted (not the set being the
target of insertion) becoming reset.  \fIunique()\fR causes the iterators of
all the participant sets becoming reset.  \fBThe iterator getting reset
most probably causes an endless loop.\fR  So avoid doing that.
.Ip "\(bu" 4
Modifying the set during the iteration may cause elements to be missed
or duplicated, or in the worst case, an endless loop; so don't do
that, either.
.Sh "Customising Display"
.IX Subsection "Customising Display"
If you want to customise the display routine you will have to
modify the \f(CW\*(C`as_string\*(C'\fR callback.  You can modify it either
for all sets by using \f(CW\*(C`as_string_callback()\*(C'\fR as a class method:
.PP
.Vb 1
\&    my $class_callback = sub { ... };
.Ve
.Vb 1
\&    Set::Scalar->as_string_callback($class_callback);
.Ve
or for specific sets by using \f(CW\*(C`as_string_callback()\*(C'\fR as an object
method:
.PP
.Vb 1
\&    my $callback = sub  { ... };
.Ve
.Vb 2
\&    $s1->as_string_callback($callback);
\&    $s2->as_string_callback($callback);
.Ve
The anonymous subroutine gets as its first (and only) argument the
set to display as a string.  For example to display the set \f(CW\*(C`$s\*(C'\fR
as \f(CW\*(C`a\-b\-c\-d\-e\*(C'\fR instead of \f(CW\*(C`(a b c d e)\*(C'\fR
.PP
.Vb 1
\&    $s->as_string_callback(sub{join("-",sort $_[0]->elements)});
.Ve
If called without an argument, the current callback is returned.
.PP
If called as a class method with undef as the only argument, the
original callback (the one returning \f(CW\*(C`(a b c d e)\*(C'\fR) for all the sets
is restored, or if called for a single set the callback is removed
(and the callback for all the sets will be used).
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi <jhi@iki.fi>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2001 by Jarkko Hietaniemi
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 
