.\" Automatically generated by Pod::Man version 1.02
.\" Wed Jan 28 14:42:54 2004
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Descriptive 3"
.TH Descriptive 3 "perl v5.6.0" "2002-10-10" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Statistics::Descriptive \- Module of basic descriptive statistical functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  use Statistics::Descriptive;
\&  $stat = Statistics::Descriptive::Full->new();
\&  $stat->add_data(1,2,3,4); $mean = $stat->mean();
\&  $var  = $stat->variance();
\&  $tm   = $stat->trimmed_mean(.25);
\&  $Statistics::Descriptive::Tolerance = 1e-10;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides basic functions used in descriptive statistics.
It has an object oriented design and supports two different types of
data storage and calculation objects: sparse and full. With the sparse
method, none of the data is stored and only a few statistical measures
are available. Using the full method, the entire data set is retained
and additional functions are available.
.PP
Whenever a division by zero may occur, the denominator is checked to be
greater than the value \f(CW\*(C`$Statistics::Descriptive::Tolerance\*(C'\fR, which
defaults to 0.0. You may want to change this value to some small
positive value such as 1e-24 in order to obtain error messages in case
of very small denominators.
.PP
Many of the methods (both Sparse and Full) cache values so that subsequent
calls with the same arguments are faster.
.SH "METHODS"
.IX Header "METHODS"
.Sh "Sparse Methods"
.IX Subsection "Sparse Methods"
.Ip "$stat = Statistics::Descriptive::Sparse->\fInew()\fR;" 5
.IX Item "$stat = Statistics::Descriptive::Sparse->new();"
Create a new sparse statistics object.
.Ip "$stat->add_data(1,2,3);" 5
.IX Item "$stat->add_data(1,2,3);"
Adds data to the statistics variable. The cached statistical values are 
updated automatically.
.Ip "$stat->\fIcount()\fR;" 5
.IX Item "$stat->count();"
Returns the number of data items.
.Ip "$stat->\fImean()\fR;" 5
.IX Item "$stat->mean();"
Returns the mean of the data.
.Ip "$stat->\fIsum()\fR;" 5
.IX Item "$stat->sum();"
Returns the sum of the data.
.Ip "$stat->\fIvariance()\fR;" 5
.IX Item "$stat->variance();"
Returns the variance of the data.  Division by n-1 is used.
.Ip "$stat->\fIstandard_deviation()\fR;" 5
.IX Item "$stat->standard_deviation();"
Returns the standard deviation of the data. Division by n-1 is used.
.Ip "$stat->\fImin()\fR;" 5
.IX Item "$stat->min();"
Returns the minimum value of the data set.
.Ip "$stat->\fImindex()\fR;" 5
.IX Item "$stat->mindex();"
Returns the index of the minimum value of the data set.
.Ip "$stat->\fImax()\fR;" 5
.IX Item "$stat->max();"
Returns the maximum value of the data set.
.Ip "$stat->\fImaxdex()\fR;" 5
.IX Item "$stat->maxdex();"
Returns the index of the maximum value of the data set.
.Ip "$stat->\fIsample_range()\fR;" 5
.IX Item "$stat->sample_range();"
Returns the sample range (max \- min) of the data set.
.Sh "Full Methods"
.IX Subsection "Full Methods"
Similar to the Sparse Methods above, any Full Method that is called caches
the current result so that it doesn't have to be recalculated.  In some
cases, several values can be cached at the same time.
.Ip "$stat = Statistics::Descriptive::Full->\fInew()\fR;" 5
.IX Item "$stat = Statistics::Descriptive::Full->new();"
Create a new statistics object that inherits from
Statistics::Descriptive::Sparse so that it contains all the methods
described above.
.Ip "$stat->add_data(1,2,4,5);" 5
.IX Item "$stat->add_data(1,2,4,5);"
Adds data to the statistics variable.  All of the sparse statistical
values are updated and cached.  Cached values from Full methods are
deleted since they are no longer valid.  
.Sp
\&\fINote:  Calling add_data with an empty array will delete all of your
Full method cached values!  Cached values for the sparse methods are
not changed\fR
.Ip "$stat->\fIget_data()\fR;" 5
.IX Item "$stat->get_data();"
Returns a copy of the data array.
.Ip "$stat->\fIsort_data()\fR;" 5
.IX Item "$stat->sort_data();"
Sort the stored data and update the mindex and maxdex methods.  This
method uses perl's internal sort.
.Ip "$stat->\fIpresorted\fR\|(1);" 5
.IX Item "$stat->presorted;"
.Ip "$stat->\fIpresorted()\fR;" 5
.IX Item "$stat->presorted();"
If called with a non-zero argument, this method sets a flag that says
the data is already sorted and need not be sorted again.  Since some of
the methods in this class require sorted data, this saves some time.
If you supply sorted data to the object, call this method to prevent
the data from being sorted again. The flag is cleared whenever add_data
is called.  Calling the method without an argument returns the value of
the flag.
.Ip "$x = \f(CW$stat\fR->percentile(25);" 5
.IX Item "$x = $stat->percentile(25);"
.Ip "($x, \f(CW$index\fR) = \f(CW$stat\fR->percentile(25);" 5
.IX Item "($x, $index) = $stat->percentile(25);"
Sorts the data and returns the value that corresponds to the
percentile as defined in \s-1RFC2330:\s0
.RS 5
.Ip "" 4
For example, given the 6 measurements:
.Sp
\&\-2, 7, 7, 4, 18, \-5
.Sp
Then F(\-8) = 0, F(\-5) = 1/6, F(\-5.0001) = 0, F(\-4.999) = 1/6, F(7) =
5/6, F(18) = 1, F(239) = 1.
.Sp
Note that we can recover the different measured values and how many
times each occurred from F(x) \*(-- no information regarding the range
in values is lost.  Summarizing measurements using histograms, on the
other hand, in general loses information about the different values
observed, so the \s-1EDF\s0 is preferred.
.Sp
Using either the \s-1EDF\s0 or a histogram, however, we do lose information
regarding the order in which the values were observed.  Whether this
loss is potentially significant will depend on the metric being
measured.
.Sp
We will use the term \*(L"percentile\*(R" to refer to the smallest value of x
for which F(x) >= a given percentage.  So the 50th percentile of the
example above is 4, since F(4) = 3/6 = 50%; the 25th percentile is
\&\-2, since F(\-5) = 1/6 < 25%, and F(\-2) = 2/6 >= 25%; the 100th
percentile is 18; and the 0th percentile is \-infinity, as is the 15th
percentile.
.Sp
Care must be taken when using percentiles to summarize a sample,
because they can lend an unwarranted appearance of more precision
than is really available.  Any such summary must include the sample
size N, because any percentile difference finer than 1/N is below the
resolution of the sample.
.RE
.RS 5
.Sp
(Taken from:
\&\fI\s-1RFC2330\s0 \- Framework for \s-1IP\s0 Performance Metrics\fR,
Section 11.3.  Defining Statistical Distributions.
\&\s-1RFC2330\s0 is available from:
http://www.cis.ohio-state.edu/htbin/rfc/rfc2330.html.)
.Sp
If the percentile method is called in a list context then it will
also return the index of the percentile.
.RE
.Ip "$stat->\fImedian()\fR;" 5
.IX Item "$stat->median();"
Sorts the data and returns the median value of the data.
.Ip "$stat->\fIharmonic_mean()\fR;" 5
.IX Item "$stat->harmonic_mean();"
Returns the harmonic mean of the data.  Since the mean is undefined
if any of the data are zero or if the sum of the reciprocals is zero,
it will return undef for both of those cases.
.Ip "$stat->\fIgeometric_mean()\fR;" 5
.IX Item "$stat->geometric_mean();"
Returns the geometric mean of the data.
.Ip "$stat->\fImode()\fR;" 5
.IX Item "$stat->mode();"
Returns the mode of the data. 
.Ip "$stat->trimmed_mean(ltrim[,utrim]);" 5
.IX Item "$stat->trimmed_mean(ltrim[,utrim]);"
\&\f(CW\*(C`trimmed_mean(ltrim)\*(C'\fR returns the mean with a fraction \f(CW\*(C`ltrim\*(C'\fR 
of entries at each end dropped. \f(CW\*(C`trimmed_mean(ltrim,utrim)\*(C'\fR 
returns the mean after a fraction \f(CW\*(C`ltrim\*(C'\fR has been removed from the
lower end of the data and a fraction \f(CW\*(C`utrim\*(C'\fR has been removed from the
upper end of the data.  This method sorts the data before beginning
to analyze it.
.Sp
All calls to \fItrimmed_mean()\fR are cached so that they don't have to be
calculated a second time.
.Ip "$stat->frequency_distribution($partitions);" 5
.IX Item "$stat->frequency_distribution($partitions);"
.Ip "$stat->frequency_distribution(\e@bins);" 5
.IX Item "$stat->frequency_distribution(@bins);"
.Ip "$stat->\fIfrequency_distribution()\fR;" 5
.IX Item "$stat->frequency_distribution();"
\&\f(CW\*(C`frequency_distribution($partitions)\*(C'\fR slices the data into
\&\f(CW\*(C`$partition\*(C'\fR sets (where \f(CW$partition\fR is greater than 1) and counts the
number of items that fall into each partition. It returns an
associative array where the keys are the numerical values of the
partitions used. The minimum value of the data set is not a key and the
maximum value of the data set is always a key. The number of entries
for a particular partition key are the number of items which are
greater than the previous partition key and less then or equal to the
current partition key. As an example,
.Sp
.Vb 5
\&   $stat->add_data(1,1.5,2,2.5,3,3.5,4);
\&   %f = $stat->frequency_distribution(2);
\&   for (sort {$a <=> $b} keys %f) {
\&      print "key = $_, count = $f{$_}\en";
\&   }
.Ve
prints
.Sp
.Vb 2
\&   key = 2.5, count = 4
\&   key = 4, count = 3
.Ve
since there are four items less than or equal to 2.5, and 3 items
greater than 2.5 and less than 4.
.Sp
\&\f(CW\*(C`frequency_distribution(\e@bins)\*(C'\fR provides the bins that are to be used
for the distribution.  This allows for non-uniform distributions as
well as trimmed or sample distributions to be found.  \f(CW\*(C`@bins\*(C'\fR must
be monotonic and contain at least one element.  Note that unless the
set of bins contains the range that the total counts returned will
be less than the sample size.
.Sp
Calling \f(CW\*(C`frequency_distribution()\*(C'\fR with no arguments returns the last
distribution calculated, if such exists.
.Ip "$stat->\fIleast_squares_fit()\fR;" 5
.IX Item "$stat->least_squares_fit();"
.Ip "$stat->least_squares_fit(@x);" 5
.IX Item "$stat->least_squares_fit(@x);"
\&\f(CW\*(C`least_squares_fit()\*(C'\fR performs a least squares fit on the data,
assuming a domain of \f(CW\*(C`@x\*(C'\fR or a default of 1..$stat->\fIcount()\fR.  It
returns an array of four elements \f(CW\*(C`($q, $m, $r, $rms)\*(C'\fR where
.RS 5
.Ip "\f(CW\*(C`$q and $m\*(C'\fR" 4
.IX Item "$q and $m"
satisfy the equation C($y = \f(CW$m\fR*$x + \f(CW$q\fR).
.Ip "\f(CW\*(C`$r\*(C'\fR" 4
.IX Item "$r"
is the Pearson linear correlation cofficient.
.Ip "\f(CW\*(C`$rms\*(C'\fR" 4
.IX Item "$rms"
is the root-mean-square error.
.RE
.RS 5
.Sp
If case of error or division by zero, the empty list is returned.
.Sp
The array that is returned can be \*(L"coerced\*(R" into a hash structure
by doing the following:
.Sp
.Vb 2
\&  my %hash = ();
\&  @hash{'q', 'm', 'r', 'err'} = $stat->least_squares_fit();
.Ve
Because calling \f(CW\*(C`least_squares_fit()\*(C'\fR with no arguments defaults
to using the current range, there is no caching of the results.
.RE
.SH "REPORTING ERRORS"
.IX Header "REPORTING ERRORS"
I read my email frequently, but since adopting this module I've added 2
children and 1 dog to my family, so please be patient about my response
times.  When reporting errors, please include the following to help
me out:
.Ip "\(bu" 4
Your version of perl.  This can be obtained by typing perl \f(CW\*(C`\-v\*(C'\fR at
the command line.
.Ip "\(bu" 4
Which version of Statistics::Descriptive you're using.  As you can
see below, I do make mistakes.  Unfortunately for me, right now
there are thousands of \s-1CD\s0's with the version of this module with
the bugs in it.  Fortunately for you, I'm a very patient module
maintainer.
.Ip "\(bu" 4
Details about what the error is.  Try to narrow down the scope
of the problem and send me code that I can run to verify and
track it down.
.SH "AUTHOR"
.IX Header "AUTHOR"
Colin Kuskie
.PP
My email address can be found at http://www.perl.com under Who's Who
or at: http://search.cpan.org/author/COLINK/.
.SH "REFERENCES"
.IX Header "REFERENCES"
\&\s-1RFC2330\s0, Framework for \s-1IP\s0 Performance Metrics
.PP
The Art of Computer Programming, Volume 2, Donald Knuth.
.PP
Handbook of Mathematica Functions, Milton Abramowitz and Irene Stegun.
.PP
Probability and Statistics for Engineering and the Sciences, Jay Devore.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997,1998 Colin Kuskie. All rights reserved.  This
program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Copyright (c) 1998 Andrea Spinelli. All rights reserved.  This program
is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.
.PP
Copyright (c) 1994,1995 Jason Kastner. All rights
reserved.  This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.SH "REVISION HISTORY"
.IX Header "REVISION HISTORY"
.Ip "v2.3"
.IX Item "v2.3"
Rolled into November 1998
.PP
Code provided by Andrea Spinelli to prevent division by zero and to
make consistent return values for undefined behavior.  Andrea also
provided a test bench for the module.
.PP
A bug fix for the calculation of frequency distributions.  Thanks to Nick
Tolli for alerting this to me.
.PP
Added 4 lines of code to Makefile.PL to make it easier for the ActiveState
installation tool to use.  Changes work fine in perl5.004_04, haven't
tested them under perl5.005xx yet.
.Ip "v2.2"
.IX Item "v2.2"
Rolled into March 1998.
.PP
Fixed problem with sending 0's and \-1's as data.  The old 0 : true ? false
thing.  Use defined to fix.
.PP
Provided a fix for AUTOLOAD/DESTROY/Carp bug.  Very strange.
.Ip "v2.1"
.IX Item "v2.1"
August 1997
.PP
Fixed errors in statistics algorithms caused by changing the
interface.
.Ip "v2.0"
.IX Item "v2.0"
August 1997
.PP
Fixed errors in removing cached values (they weren't being removed!)
and added sort_data and presorted methods.
.PP
June 1997
.PP
Transferred ownership of the module from Jason to Colin.
.PP
Rewrote \s-1OO\s0 interface, modified function distribution, added mindex,
maxdex.
.Ip "v1.1"
.IX Item "v1.1"
April 1995
.PP
Added LeastSquaresFit and FrequencyDistribution.
.Ip "v1.0"
.IX Item "v1.0"
March 1995
.PP
Released to comp.lang.perl and placed on archive sites.
.Ip "v.20"
.IX Item "v.20"
December 1994
.PP
Complete rewrite after extensive and invaluable e-mail 
correspondence with Anno Siegel.
.Ip "v.10"
.IX Item "v.10"
December 1994
.PP
Initital concept, released to perl5\-porters list.
