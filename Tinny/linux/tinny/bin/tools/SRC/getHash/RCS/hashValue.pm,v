head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	2002.01.23.21.31.59;	author pcd;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/sw/perl/bin/perl -w
# 
# Copies the function of drv_falcon's or sampstat's hashValue routine.
#
# About 20 times slower than doing it in C!  But it saves function call
# overhead in a perl script.  With the function call overhead included,
# it takes the shell/C program combo 35 times _longer_ to do this.
#
# Input:
#    1 -- $acct
#    2 -- $hashType
#    3 -- $hashDirection
#
# Author: Paul C. Dulany (pcd) 12/8/99
#
# Based upon algorithms from drv_falcon and sampstats.
#

package hashValue;

$hashValue::testTrain = 0;
$hashValue::sampstats = 1;

$hashValue::forward = 0;
$hashValue::backward = 1;


##########################


$hashValue::KEYLENMAX = 19;
$hashValue::backwardHash = 0;

@@hashValue::coprime_drv_falcon = (11, 13, 17, 19, 23, 31);
@@hashValue::coprime_samp_stats = (33, 47, 53, 17, 27, 41);


sub hashValue {
   #
   # Input:
   #    1 -- $acct
   #    2 -- $hashType
   #    3 -- $hashDirection
   #

   use strict 'vars';
   use integer;
   my ($acct, $hashType, $hashDirection) = @@_;
   my (@@acct_chars);
   my ($i, $j, $k, $sum);
   my ($zero, @@coprime);


   #   signed chars --- SunOs
   @@acct_chars = unpack "c$hashValue::KEYLENMAX", $acct;
   $zero = unpack "c", '0';


   # print "acct=$acct, Type=$hashType, Dir=$hashDirection\n";

   if ($hashType == $hashValue::testTrain) {
      @@coprime = @@hashValue::coprime_drv_falcon;
   } else {
       @@coprime = @@hashValue::coprime_samp_stats;
   }


   # The '-' in the following check is for Capital One; in sampstats.
   for ($i = scalar(@@acct_chars) - 1;
        ! $acct_chars[$i] =~ /a-zA-Z0-9-/o  && $i;
        $i--) {
   }


   if ($i < 12) {
      printf STDERR
         "Account number found of length only %d in hashValue!\n",
         $i+1;
      return (-1);
   }



   $sum = 0;
   if ($hashDirection == $hashValue::forward) {
      for ($k=0, $j=$i-12; $k<6; $i--, $j++, $k++) {
         $sum += ( (($acct_chars[$j] - $zero) * 10) +
                   ($acct_chars[$i] - $zero)
                 ) * $coprime[$k];
      }
   } else {
      for ($k=0, $j=$i-12; $k<6; $i--, $j++, $k++) {
         $sum += ( (($acct_chars[$i] - $zero) * 10) +
                   ($acct_chars[$j] - $zero)
                 ) * $coprime[$k];
      }
   }



   return ($sum % 100);
}

#  while ($line = <>) {
#     $acct = substr ($line, 0, $KEYLENMAX);
#     printf "%s = %d, %d, %d, %d\n", $acct,
#        hashValue ($acct, 0, 0),
#        hashValue ($acct, 0, 1),
#        hashValue ($acct, 1, 0),
#        hashValue ($acct, 1, 1);
#  }

@
