#! /usr/local/bin/perl -w


my $VERSION = '5.0';
my $DEBUG = 1;
my $USAGE =<< "xxxEOFxxx";

################################################################################################
# Product:
#         MSG /MDW-FRAUD Tables 
# Module:
#			$0 [-p] <credit/debit/retail> ([-f] <tape client> or
#				[-t <TSYS client> -l <tsys client hash> -v <length>])
# Purpose:
#         To update the TABLES related to Fraud:
#    		     FRAUD_MONTH_DATA
#	  by overwriting the existing records if re-processed.
#               	  
#         1) Add 6 fields in the table:
#				 VALID_FIRSTFRAUD_DATE_PCT         
#			    VALID_BLOCK_DATE_PCT              
#				 FIRST_FRAUD_COUNT_YYYYMM_3        
#				 FIRST_FRAUD_COUNT_YYYYMM_2        
#				 BLOCK_FRAUD_COUNT_YYYYMM          
#				 COMMENTS                          
#			 2) Add an option to process tsys clients
#			 3) Add an option to process usr/pwd
#			 4) Add a check for avoiding to process the empty file
#			    and print a warning message for it. 
#			 5) Add # of input files in the comments and a health check for
#			 wrong lengh input. 
#                     
# Arguments:
#        -p: portfolio type, Credit/Debit/Retail
#
# Options:
#        -f: frauds file names from Tape clients 
#	 	   -t: frauds file names from TSYS clients 
#   		-l: TSYS client hash table should be specified while -t option is chose. 
#			-v: record length should be specified while -t option is chose. 
#			-d: User/Password schema dev is required.
# 		   -h: to show the usage
#
# Input:
#         No stdin. 
#
# Output:
#       Error mesasge will go to STDERR and notes go to STDOUT. 
#
# Return:
#       Update the related FRAUD tables in MDW
#
# Usage:
#       Process the same month data per client
#
# Examples:
#
# 		1) To run all the multiple files of the same month per tape client:
#		./fraudData.pl -p credit -f "/ana/mds_files1/iFALCON/ANZ/0412/0412.anz.fraud.0581*" -d /ana/mds_files5/MetaDataWarehouse/system/.password
#		2)	To run only one month frauds file per client:
#		./fraudData.pl -p credit -f /ana/mds_files1/iFALCON/WESTPAC/0506/0506.westpac.fraud.064028E.91.ebcdic.gz -d /ana/mds_files5/MetaDataWarehouse/system/.password
#		3) To run all the mulitple files of the same month per tsys client:
#		./fraudData.pl -p credit -t "/ana/mds_files4/TOTALSYS/TS2/5730/0504/CASE/TS2_5730_CASE.10504*"  -l tsys.client.hash -v 49 -d /ana/mds_files5/MetaDataWarehouse/system/.password
#		4) To run only one month frauds file per client:
#		./fraudData.pl -p credit -t /ana/mds_files4/TOTALSYS/TS2/2320/0504/CASE/TS2_2320_CASE.1050514.20050401.gz -l tsys.client.hash -v 49 -d /ana/mds_files5/MetaDataWarehouse/system/.password
#                      
# Revision History:
#          Authors             Date                 Involvement
#          yxc                8/18/05               Creator
#          yxc                8/30/05               
#			  yxc						9/6/05
#			  yxc  					9/8/05
#			  yxc						9/13/05
#			  yxc						9/16/05					 
#
#
# Notes: -t option and -f option cannot be used at the same time. 
#                
#######################################################################################
xxxEOFxxx

use strict;
use DBI;
use Getopt::Std;
use File::stat;
use Data::Dumper;
$Data::Dumper::Purity=1;

use lib ("/home/jfa/perl/lib/perl5/site_perl/5.8.2/sun4-solaris", "/home/jfa/perl/lib/perl5/site_perl/5.8.2");
use Date::Calc ("check_date");

############################################################
#       Write start time, machine name and version
############################################################
my $tmp = `date`;
chomp $tmp;
my $sttime=$tmp;
print STDOUT "Command line: $0 @ARGV\n";
print STDOUT ("Starting on $tmp\n");
$tmp = `uname -ns`;
chomp $tmp;
print STDOUT ("Host is $tmp\n");
print STDOUT ("Version $VERSION\n\n");


############################################################
#	Process options
############################################################
die "$USAGE" if ($#ARGV == -1 );
my %opts = ();
&getopts('f:p:t:l:v:d:h', \%opts);
die "$USAGE" if (defined $opts{'h'});
die "ERROR: Portfolio type required\n" unless (defined $opts{'p'});

#if (defined $opts{'f'} && (!defined$opts{'t'}))
die "ERROR: fraud files required\n" unless (defined $opts{'f'} || defined $opts{'t'});
die "ERROR: Schema/Dev is required\n" unless (defined $opts{'d'});
die "ERROR: Schema/Dev must be non-empty\n" unless (-f $opts{'d'} and -s _);

if (defined $opts{'t'}) {
	  		die "ERROR: Tsys client Hash table is required since -t is chose\n" unless (defined $opts{'l'});
			die "ERROR: Data specification version is required since -t is	chose\n" unless (defined $opts{'v'});
			die "ERROR: Wrong value \'$opts{'v'}\' for -v. Only actual length is valid\n" unless ($opts{'v'} =~ /^\d+$/ );
}

############################################################
#	Set portfolio field, comment field with timestamp
############################################################

my $prtfls = $opts{'p'}; 
$prtfls=~ tr/[A-Z]/[a-z]/;
my %outH = ();

$outH{'comments'} ="$sttime" ;
$outH{'portfolio'} ="$prtfls" ;
############################################################
#	Collect fraud file names
############################################################
print STDOUT "Frauds Files:\n";
# Allow for a comma delimited file list
my ($file, @file_list, $temp, @temp_list);
@file_list=();

if (defined $opts{'f'}){
		my @list = split(",", $opts{'f'});
		for $temp (@list) {
			 # Allow for wildcards in each file name
      		  for $file (glob $temp) {
            		    next unless (-f $file);
		                die "ERROR: I need read permissions for '$file'\n" unless (-r _);
							my $ref = stat($file); 
						 	my $size = $ref->size;
							
							if ($size >20) {	
							 push (@temp_list, $file);
							 print STDOUT "\t$file\n";
						 	} else { print STDERR "WARN: $file seems empty. \n";
							}
		        }
		}
} elsif (defined $opts{'t'}){
		my @list = split(",", $opts{'t'});
		for $temp (@list) {
			 # Allow for wildcards in each file name
      		  for $file (glob $temp) {
            		    next unless (-f $file);
		                die "ERROR: I need read permissions for '$file'\n" unless (-r _);
      		         my $ref = stat($file); 
						 	my $size = $ref->size;
							
							if ($size > 20) {	
							 push (@temp_list, $file);
							 print STDOUT "\t$file\n";
						 	} else { print STDERR "WARN: $file seems empty. \n";
							}
		        }
		}
} else {
	die "$USAGE";
	exit (1);
}
@file_list = dedup(@temp_list); 
die "ERROR: No files to process\n" unless ($#file_list > -1);
my $num=$#file_list + 1; 
$outH{'comments'} .= " , " . "$num" ;

############################################################
#	Parse frauds file names for tape files or T1 files
#	Set 'client_id' and 'date_yyyymm'
############################################################

if (defined $opts{'f'}) 
{
	 my ($name,$date, $yymm, $client, $content, $length, $format, $ext, $inventory);

	for $file (@file_list) {
	    $name = substr($file, rindex($file,'/')+1);
		($date, $client, $content, $inventory, $length, $format, $ext) = split(/\./, $name);
	
	# File name format:  yymm.client.content.inventory_number.record_length.format.gz
		unless ((defined $date) && ($date =~ /^\d{4}/)) {
			die "ERROR: Incorrect 'date' field in '$name'\n";
  		}
		$yymm=substr($date,0,4); 
		my ($yyyy, $mm) = unpack ('a4 a2', "20" . $yymm); 
		die "Invalid 'date' field in '$name'\n" unless (check_date($yyyy, $mm, 1));
		unless ((defined $content) && ($content =~ /^fraud/i)) {
			die "ERROR: Content type must be 'fraud*':  $name\n";
		}
		unless ((defined $length) && ($length =~ /^\d+$/)) {
			die "ERROR: Incorrect 'record_length' field in '$name'\n";
		}
		unless ((defined $format) && (($format=~/^ascii/i) ||
			  ($format=~/^ebcdic/i) || ($format =~/^mxfrmt/i))) {
			die "ERROR: Incorrect 'format' field in '$name'\n";
	  }
   }
} 
elsif (defined $opts{'t'}) 
{
	my ($name, $yyyymm, $client,$sent,  $content, $ext, $temp, $chanel, $length, %tsysClient, $estMon, @temp);
    
	for $file (@file_list) {
		 $name = substr($file, rindex($file,'/')+1);
	    @temp = split('/', $file); 
		 my $yymm = $temp[6]; 
		 
		($temp, $sent, $estMon, $ext) = split(/\./, $name);
		($chanel, $client, $content) = split(/\_/, $temp);
		
		# TSYS File name format:  TS1{2}_$client_$content.$receive.$yyyymmdd.gz
		$yyyymm= "20" . $yymm; 
		
 		unless ((defined $yyyymm) && ($yyyymm =~ /^\d{6}/)) {
 			die "ERROR: Incorrect 'date' field in '$name'\n";
   		}
   		my ($yyyy, $mm) = unpack ('a4 a2', $yyyymm);
 		die "ERROR: Invalid 'date' field in '$name'\n" unless (check_date($yyyy, $mm, 1));
 	
 		unless ((defined $content) && ($content =~ /^case/i)) {
 			die "ERROR: Content type must be 'fraud*':  $name\n";
 		}
 
 		#### Load tsysClient hash table from option  
 		open (SAVE, "< $opts{'l'}") || die "Couldn't open $opts{'l'} :$!";
 	 #  undef $/;  # read in file at once
	 	local $/; 
	   eval <SAVE>;
 	   die "can't recreate the hashes from  $opts{'l'} : $@" if $@;
 	   close SAVE or die "can't close SAVE: $!"; 
 
 		unless ((defined $client) && (defined $tsysClient{$client})) {
 			die "ERROR: This client ID $client is not found. Find the name and
 			update the client hash table first: \n";
	  }
	}
  $outH{'client'}=$tsysClient{$client};
	
} 
else
{
	die "$USAGE";
	exit (1);

}

################################################################
#	Process frauds files
#	push 'data_size', 'rec_count' into Hash array
############################################################
my ($yyyymm_3, $yyyymm_2, $bin1, $check, $checkR);
my $ffd_good=0;
my $fdd_good=0;  
my %ffdHC = ();
my %fddHC = ();
my %binH = (); 

$outH{'size'} = 0;
$outH{'recCount'} = 0; 


if (defined $opts{'f'}){
 	 my ($name,$date, $yymm, $client, $content, $length, $format, $ext, $inventory) ;
	 for $file (@file_list) {
		   
		   $name = substr($file, rindex($file,'/')+1);
		($date, $client, $content, $inventory, $length, $format, $ext) = split(/\./, $name); 
		$yymm=substr($date,0,4);
	$outH{'comments'} .= " , " . $name;	
		$client =~ tr/[A-Z]/[a-z]/; 
		$outH{'client'} = $client; 	
      my ($yyyy, $mm) = unpack 'a4 a2', ('20' . $yymm);
		my $yyyymm = $yyyy . $mm;
		$outH{'date_yyyymm'}=$yyyymm;
			
		if ($mm < 4) {
			$yyyymm_3 = $yyyymm - 91;	
	  	} else {
 			$yyyymm_3 = $yyyymm - 3; 
 		}

		if ($mm < 3) {
			$yyyymm_2 = $yyyymm - 90;	
	  	} else {
 			$yyyymm_2 = $yyyymm - 2; 
 		}
	
		my $ref = stat($file);
		$outH{'size'} += $ref->size;

	  
	  my $cmd = '';
		if (($ext =~ /^gz$/i) || ($ext =~ /^Z$/i)) {
				$cmd = "/usr/local/bin/gunzip -c $file | ";
		} elsif ($ext =~ /^zip$/i) {
				$cmd = "/usr/local/bin/unzip -c $file | ";		
		} else {
				$cmd = "/usr/local/bin/cat $file | ";
		}
		
		if (($format =~ /ebcdic/i) || ($format =~ /mxfrmt/i)) {
				$cmd .= "/usr/local/bin/dd conv=ascii | /work/price/falcon/bin/addnl $length | ";
  		}
		open (FIN, $cmd) || die "ERROR: Unable to open $file for reading\n";
	
		print STDERR "###>>>  HERE is the file: $file  <<<###\n";

  		while (defined ($_ = <FIN>)) {
			 
			 $outH{'recCount'} ++;
				
			 	$bin1=substr($_,0,1);
				next unless ($bin1 =~ /^\d{1}$/);
					 $check ++;	 
					
				my $ffdH = substr($_, 20,8); 
				my $fddH = substr($_, 35,8); 
 		   
		   	next unless ($ffdH =~ /^\d{8}$/);
			   my ($year, $mon, $day)= unpack 'a4 a2 a2', $ffdH;
            next unless (check_date($year, $mon, $day)); 
			   $ffd_good ++;
			
			   next unless ($fddH =~ /^\d{8}$/);
			   my ($year2, $mon2, $day2)= unpack 'a4 a2 a2', $fddH;
            next unless (check_date($year2, $mon2, $day2)); 
	   	   $fdd_good ++; 

			($ffdHC{substr($ffdH,0,6)} ++) or 
			($ffdHC{substr($ffdH,0,6)} =1);
			($fddHC{substr($fddH,0,6)} ++) or 
			($fddHC{substr($fddH,0,6)} =1);
			
		}
		close (FIN);

		if ($outH{'recCount'} > 0 ){ 
			 my $checkR = sprintf("%.2f", 100*$check/$outH{'recCount'}); 	
	 
			if ($checkR > 90) {
			 
			 $outH{'valid_ffd_pct'}=sprintf("%.0f",100*$ffd_good/$outH{'recCount'});
			 $outH{'valid_fdd_pct'}=sprintf("%.0f",100*$fdd_good/$outH{'recCount'});
			 }
			 else {
			 	die "ERROR: File length might be wrong! Process died and check $file with length of $opts{'v'}\n";
			 }
		} else {
  		 print STDERR "WARN: $file seems empty!\n";
		}


	   $outH{'ffd_count_3'} =  $ffdHC{$yyyymm_3};
		$outH{'ffd_count_2'} =  $ffdHC{$yyyymm_2};
		$outH{'fdd_count'}   =  $fddHC{$yyyymm}; 
  }
}
elsif (defined $opts{'t'}) 
{
	my ($name, @tt, $client, $content,  $temp, $chanel, @temp, $length,%tsysClient);

		for $file (@file_list) {
			
			$name = substr($file, rindex($file,'/')+1);
			@tt = split(/\./, $name);
			$temp=$tt[0];

			($chanel, $client, $content) = split(/\_/, $temp);
		   
			$outH{'comments'} .= " , " . $name; 	
			@temp = split('/', $file); 
			my $yymm = $temp[6]; 
			my $yyyymm = "20" . $yymm;
		 	my ($yyyy, $mm) = unpack ('a4 a2', $yyyymm); 

			$outH{'date_yyyymm'}= $yyyymm;
		
			if ($mm < 4) {
					$yyyymm_3 = $yyyymm - 91;	
		  	} else {
 					$yyyymm_3 = $yyyymm - 3; 
 			}

			if ($mm < 3) {
					$yyyymm_2 = $yyyymm - 90;	
		  	} else {
 					$yyyymm_2 = $yyyymm - 2; 
	 		}
	
			my $ref = stat($file);
			$outH{'size'} += $ref->size;
			
			if ($opts{'v'} =~ /^\d+$/){
				 $length= $opts{'v'};
		  	} else {
 				 die "$opts{'v'} is not valid for the length of record.\n"; 
			}
			
		  my $cmd = '';
		  if (($name =~ /gz$/i) || ($name =~ /Z$/i)) {
					$cmd = "/usr/local/bin/gunzip -c $file | /usr/local/bin/dd conv=ascii | /work/price/falcon/bin/addnl $length | ";
			} elsif ($name =~ /zip$/i) {
					$cmd = "/usr/local/bin/unzip -c $file | ";		
			} else {
					$cmd = "/usr/local/bin/cat $file | ";
			}
			
			print STDERR "\n$cmd\n\n"; 
		
			open (TIN, $cmd ) || die "ERROR: Unable to open $file for reading\n";
			
			while (defined ($_ = <TIN>)) {
				 
				$outH{'recCount'} ++;
				my $bin1=substr($_,0,1);
					next unless ($bin1 =~ /^\d{1}$/);
					 $check ++; 	
				
				my $ffdH = substr($_, 20,8); 
				my $fddH = substr($_, 35,8); 
 		   
		   	next unless ($ffdH =~ /^\d{8}$/);
			   my ($year, $mon, $day)= unpack 'a4 a2 a2', $ffdH;
            next unless (check_date($year, $mon, $day)); 
			   $ffd_good ++;
			
			   next unless ($fddH =~ /^\d{8}$/);
			   my ($year2, $mon2, $day2)= unpack 'a4 a2 a2', $fddH;
            next unless (check_date($year2, $mon2, $day2)); 
	   	   $fdd_good ++; 

			($ffdHC{substr($ffdH,0,6)}++) or 
			($ffdHC{substr($ffdH,0,6)} =1);
			($fddHC{substr($fddH,0,6)}++) or 
			($fddHC{substr($fddH,0,6)} =1);
			
	   }	
		close(TIN);

		if ($outH{'recCount'} > 0 ){
			 
			  $checkR = sprintf("%.2f", 100*$check/$outH{'recCount'}); 	
	 
				if ($checkR > 90) {
					 $outH{'valid_ffd_pct'}=sprintf("%.0f",100*$ffd_good/$outH{'recCount'});
					 $outH{'valid_fdd_pct'}=sprintf("%.0f",100*$fdd_good/$outH{'recCount'});
				}
		  		 else {
			 	die "ERROR: File length might be wrong! Process died and check	$file with length of $opts{'v'}\n";
			 	}
		} else {
  		 print STDERR "WARN: $file seems empty!\n";
  		}
   
	   $outH{'ffd_count_3'} =  $ffdHC{$yyyymm_3};
		$outH{'ffd_count_2'} =  $ffdHC{$yyyymm_2};
		$outH{'fdd_count'}   =  $fddHC{$yyyymm}; 
		$outH{'thresh'}   =  $checkR;

  }

} 
else 
{
	die "$USAGE";
	exit (1);

}

$outH{'comments'} = substr($outH{'comments'}, 0, 1000);

############################################################
#	Fill Database
############################################################
if ($DEBUG){
	foreach (keys %outH){
		 print "$_ \t\t: $outH{$_} \n";
	}	
		open (DV, "< $opts{'d'}");
		my ($usr, $pwd, $i); 
		$i=1; 
		while (<DV>){
			chomp;
			 if ($i==1){$usr = $_;}  
			 if ($i==2){$pwd = $_;}
			$i++; 	 
		 }
		close(DV);
		print STDERR "$usr : $pwd\n"; 

} else {
############################################################
#	Auth_Month_Data: Count number of records in DB
############################################################
open (DV, "< $opts{'d'}");
my ($usr, $pwd, $i); 
$i=1; 
while (<DV>){
	chomp;
	 if ($i==1){$usr = $_;}  
    if ($i==2){$pwd = $_;}
	$i++; 	 
}
close(DV);

my $dbh = DBI->connect(
	"dbi:Oracle:mdwd0",
	"$usr",
	"$pwd",
) || die "FraudData.pl: Database connection not made: $DBI::errstr\n";

my ($cmd, $sth, $count);

# Select statement
# SQL code
$cmd = "
SELECT count(*)
FROM Fraud_Month_Data
WHERE client = '$outH{'client'}'
AND portfolio = '$outH{'portfolio'}'
AND date_yyyymm = '$outH{'date_yyyymm'}'
";

# Statement handle
eval {
	$sth = $dbh->prepare($cmd);
	$sth->execute();
	($count) = $sth->fetchrow_array();
	$sth->finish();
};
 if ( $@ ) {
 	die "FraudData.pl: Fraud_Month_Data: Database error during 'SELECT count(*)': $DBI::errstr\n";
 }
 unless (defined $count) {
 	die "FraudData.pl: Fraud_Month_Data: Unable to count number of DB records for client: $outH{'client'}, portfolio: $outH{'portfolio'}, date_yyyymm: $outH{'date_yyyymm'}\n";
 }
 if ($count > 1) {
 	die "FraudData.pl: Fraud_Month_Data: More than one DB record exists for client: $outH{'client'}, portfolio: $outH{'portfolio'}, date_yyyymm: $outH{'date_yyyymm'}\n";
 }

############################################################
#	Fraud_Month_Data:
#	Insert statement if record does not exist
#	Otherwise update
############################################################
if ($count == 0) {
		$cmd = "
			INSERT INTO Fraud_Month_Data (
				client,
				date_yyyymm,
				portfolio,
				rec_count,
				data_size,
				valid_firstfraud_date_pct,
				valid_block_date_pct,
				first_fraud_count_yyyymm_3,
				first_fraud_count_yyyymm_2,
				block_fraud_count_yyyymm,
				comments
			)
			VALUES (
				'$outH{'client'}',
				'$outH{'date_yyyymm'}',
				'$outH{'portfolio'}',
				'$outH{'recCount'}',
				'$outH{'size'}',
				'$outH{'valid_ffd_pct'}',
				'$outH{'valid_fdd_pct'}',
				'$outH{'ffd_count_3'}',
				'$outH{'ffd_count_2'}',
				'$outH{'fdd_count'}',
				'$outH{'comments'}'
			)";
} else {
		$cmd = "
			UPDATE Fraud_Month_Data
				SET rec_count = '$outH{'recCount'}',
					 data_size = '$outH{'size'}',
					 valid_firstfraud_date_pct = '$outH{'valid_ffd_pct'}',
					 valid_block_date_pct = '$outH{'valid_fdd_pct'}',
					 first_fraud_count_yyyymm_3 = '$outH{'ffd_count_3'}',
					 first_fraud_count_yyyymm_2 = '$outH{'ffd_count_2'}',
					 block_fraud_count_yyyymm   = '$outH{'fdd_count'}',
					 comments = '$outH{'comments'}'
			WHERE client = '$outH{'client'}'
			AND portfolio = '$outH{'portfolio'}'
			AND date_yyyymm = '$outH{'date_yyyymm'}'
		";
}

$dbh->do($cmd) || die "FraudData.pl: Fraud_Month_Data: Database error: $DBI::errstr\n";

 
 #### Disconnect
$dbh->disconnect() || warn "FraudDate.pl: Disconnection failed: $DBI::errstr\n"; 
}
############################################################
#	End time
############################################################
$tmp = `date`;
chomp $tmp;
print STDOUT ("\nFinished on $tmp\n");

############################################################
####  Subrountines 
####  A) subrountines for dedup the duplicates elements
############################################################

sub dedup {
     my   %seen =();
     my   @uniqu = grep {! $seen{$_}++} @_;
     my  @sortuniqu = sort {$a cmp $b} @uniqu;
        return @sortuniqu;
	 }

