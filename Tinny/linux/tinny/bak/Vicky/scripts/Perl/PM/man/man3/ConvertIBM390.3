.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IBM390 3"
.TH IBM390 3 "2004-08-18" "perl v5.8.2" "User Contributed Perl Documentation"
.SH "NAME"
Convert::IBM390 \-\- functions for manipulating mainframe data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Convert::IBM390 qw(...those desired... or :all);
.Ve
.PP
.Vb 3
\&  $eb  = asc2eb($string);
\&  $asc = eb2asc($string);
\&  $asc = eb2ascp($string);
.Ve
.PP
.Vb 3
\&  $ebrecord = packeb($template, LIST...);
\&  @fields = unpackeb($template, $record);
\&  @lines = hexdump($string [,startaddr [,charset]]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBConvert::IBM390\fR supplies various functions that you may find useful
when messing with \s-1IBM\s0 System/3[679]0 data.  No functions are exported
automatically; you must ask for the ones you want.  \*(L"use ... qw(:all)\*(R"
exports all functions.
.PP
By the way, this module is called \*(L"\s-1IBM390\s0\*(R" because it will deal with
data from any mainframe operating system.  Nothing about it is
specific to \s-1MVS\s0, \s-1VM\s0, \s-1VSE\s0, or \s-1OS/390\s0.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\fBasc2eb\fR \s-1STRING\s0" 2
.IX Item "asc2eb STRING"
Converts a character string from \s-1ASCII\s0 to \s-1EBCDIC\s0.  The translation
table is taken from the \s-1LE/370\s0 code set converter \s-1EDCUI1EY\s0; it
translates \s-1ISO8859\-1\s0 to \s-1IBM\-1047\s0.  For more information, see \*(L"\s-1IBM\s0
C/\*(C+ for \s-1MVS/ESA\s0 V3R2 Programming Guide\*(R", \s-1SC09\-2164\s0.
.IP "\fBeb2asc\fR \s-1STRING\s0" 2
.IX Item "eb2asc STRING"
Converts a character string from \s-1EBCDIC\s0 to \s-1ASCII\s0.  \s-1EBCDIC\s0 character
strings ordinarily come from files transferred from mainframes
via the binary option of \s-1FTP\s0.  The translation table is taken from
the \s-1LE/370\s0 code set converter \s-1EDCUEYI1\s0; it translates \s-1IBM\-1047\s0 to
\&\s-1ISO8859\-1\s0 (see above).
.IP "\fBeb2ascp\fR \s-1STRING\s0" 2
.IX Item "eb2ascp STRING"
Like eb2asc, but the output will contain only printable \s-1ASCII\s0 characters.
.IP "\fBpackeb\fR \s-1TEMPLATE\s0 \s-1LIST\s0" 2
.IX Item "packeb TEMPLATE LIST"
This function is much like Perl's built-in \*(L"pack\*(R".  It takes a list
of values and packs it into an \s-1EBCDIC\s0 record (structure).  If
called in list context, it will return a list of one element.
The \s-1TEMPLATE\s0 is patterned after Perl's pack template but allows fewer
options.  The following characters are allowed in the template:
.Sp
.Vb 17
\&  c  (1)  Character string without translation, padded with nulls
\&  C  (1)  Character string without translation, padded with native
\&          spaces
\&  e  (1)  ASCII string to be translated into EBCDIC, padded with nulls
\&  E  (1)  ASCII string to be translated into EBCDIC, padded with EBCDIC
\&          spaces
\&  h  (1)  A hexadecimal string, high nybble always first
\&  i  (2)  Signed integer (S/390 fullword)
\&  p  (1)  Packed-decimal field (default length = 8)
\&  P  (1)  Packed-decimal field with F signs for positive numbers
\&          (sometimes called "unsigned") (default length = 8)
\&  s  (2)  Signed short integer (S/390 halfword)
\&  S  (2)  Unsigned short integer (2 bytes)      
\&  t  (2)  SMF timestamp (time + date, 8 bytes)
\&  x  (2)  A null byte
\&  z  (1)  Zoned-decimal field (default length = 8)
\&  @       Null-fill to absolute offset
.Ve
.Sp
.Vb 3
\& (1) May be followed by a number giving the length of the output field;
\&     or, for hexadecimal, the number of nybbles in the input.
\& (2) May be followed by a number giving the repeat count.
.Ve
.Sp
Each character may be followed by a number giving either the length
of the field or a repeat count, as shown above.  Types 'i', 's', and
\&'S' will gobble the specified number of items from the list; if '*' is
given as the length, all the remaining items will be gobbled.  All
other types will gobble only one item; you will usually want to give
a length for the output field.  The following defaults apply:
.Sp
.Vb 4
\&  Conversion                No length given   '*' given
\&  Character string [cCeE]   1                 Same length as input
\&  Hex string [hH]           2                 Same length as input
\&  Decimal [pz]              8                 8
.Ve
.Sp
The number must immediately follow the character, but whitespace may
appear between field specifiers.
.Sp
The length for packed (p) or zoned (z) fields may include a number
of decimal places,
which is added after the byte count and a '.'.  For instance, \*(L"p3.2\*(R"
indicates a 3\-byte (5\-digit) packed field with 2 implied decimal
places; if the corresponding list element is 24.68, the result will
be x'02468C'.
Likewise, \*(L"z7.2\*(R" indicates a 7\-byte (7\-digit) zoned field with 2
implied decimal places; if the input is \-35.79, the result will be
\&'000357R' in \s-1EBCDIC\s0.
The number of implied decimals may be greater than the number of digits,
but such a specification will usually cause you to lose part of your
value; e.g., packing .589 with \*(L"p3.6\*(R" would yield x'89000c'.
If the input is not a valid Perl number, the results are unpredictable
(since they depend on internal Perl code), but most likely the output
field will contain zero.
.Sp
\&'p' will produce packed fields with the preferred sign characters: 
C for positive, D for negative. 'P' will produce F for positive
(sometimes called \*(L"unsigned\*(R") and D for negative.
.Sp
Zoned output will always have an overpunch in the last byte for the sign
(e.g., x'C1' (\s-1EBCDIC\s0 'A') for +1 or x'D3' (\s-1EBCDIC\s0 'L') for \-3).  If
you want unsigned numbers, you can use \fIsprintf()\fR and then translate
the result: e.g., \f(CW\*(C`asc2eb(sprintf("%08d", $num))\*(C'\fR.
.Sp
The ASCII-to-EBCDIC translation used by [Ee] is the same as in
\&\fIasc2eb()\fR.
.Sp
Either 'h' or 'H' may be used to request hexadecimal conversion.  This
conversion is exactly the same as in the Perl pack function, except
that the high nybble must always come first in the input.
.Sp
Type 't' takes a Unix time value (integer) and produces an \s-1SMF\s0
timestamp (a 4\-byte time followed by a 4\-byte date).  Since this
module cannot be aware of the time zone on the target mainframe, the
time value is treated as if it were \s-1UTC\s0 (\s-1GMT\s0).  You may have to
adjust the time accordingly; for instance, if your target mainframe
is running on Eastern time, you will probably want to subtract 
18000 (= 5 hours * 3600 sec/hr) from the time before packing it.
.Sp
The maximum length of a packed field is 16 bytes; of a zoned field, 32
bytes.  All other fields may have a maximum specifier (length or repeat
count) of 32767.  The maximum length of the output structure is 36KB.
These maxima are enforced.
.IP "\fBunpackeb\fR \s-1TEMPLATE\s0 \s-1RECORD\s0" 2
.IX Item "unpackeb TEMPLATE RECORD"
This function is much like Perl's built-in \*(L"unpack\*(R".  It takes an
\&\s-1EBCDIC\s0 record (structure) and unpacks it into a list of values.  If
called in scalar context, it will return only the first unpacked value.
The \s-1TEMPLATE\s0 is patterned after Perl's unpack template but allows fewer
options.  The following characters are allowed in the template:
.Sp
.Vb 14
\&  c or C (1)   Character string without translation
\&  e      (1)   EBCDIC string to be translated into ASCII; preserve
\&               trailing nulls and spaces
\&  E      (1)   EBCDIC string to be translated into ASCII; strip
\&               trailing nulls and spaces
\&  i      (2)   Signed integer (S/390 fullword)
\&  I      (2)   Unsigned integer (4 bytes)
\&  p      (1)   Packed-decimal field
\&  s      (2)   Signed short integer (S/390 halfword)
\&  S      (2)   Unsigned short integer (2 bytes) 
\&  t      (2)   SMF timestamp (time + date, 8 bytes)
\&  v      (2)   EBCDIC varchar string
\&  x      (1)   Ignore these bytes
\&  z      (1)   Zoned-decimal field
.Ve
.Sp
.Vb 2
\& (1) May be followed by a number giving the length of the field.
\& (2) May be followed by a number giving the repeat count.
.Ve
.Sp
Each character may be followed by a number giving either the length
of the field or a repeat count, as shown above, or by '*', which means
to use however many items are left in the string.  The number must
immediately follow the character, but whitespace may appear between
field specifiers.
.Sp
The length for packed (p) or zoned (z) fields may include a number
of decimal places,
which is added after the byte count and a '.'.  For instance, \*(L"p3.2\*(R"
indicates a 3\-byte (5\-digit) packed field with 2 implied decimal
places; if this field contains x'02468C', the result will be 24.68.
Likewise, \*(L"z7.2\*(R" indicates a 7\-byte (7\-digit) zoned field with 2
implied decimal places; if this field contains '000357R' (in \s-1EBCDIC\s0),
the result will be \-35.79.
The number of implied decimals may be greater than the number of digits;
e.g., unpacking the packed field above with \*(L"p3.6\*(R" would yield 0.002468.
Zoned input fields may, but need not, have an overpunch sign in the
last byte.
If the field is not a valid packed or zoned field, the resulting
element of the list will be undefined.
.Sp
Varchar (v) fields are assumed to consist of a signed halfword (16\-bit)
integer followed by \s-1EBCDIC\s0 characters.  If the number appearing in the
initial halfword is N, the following N bytes are translated from \s-1EBCDIC\s0
to \s-1ASCII\s0 and returned as one string.  This format is used, for
instance, by \s-1DB2/MVS\s0.  A repeat count may be specified; e.g., \*(L"v2\*(R" does
not mean a length of 2 bytes, but that there are two such fields in
succession.  If the length is found to be less than 0, the resulting
element of the list will be undefined.
.Sp
The EBCDIC-to-ASCII translation used by [Eev] is the same as in
\&\fIeb2asc()\fR.
.Sp
Type 't' reads an \s-1SMF\s0 timestamp (a 4\-byte time followed by a 4\-byte
date) and produces a Unix time value.  The hundredths of a second
in the \s-1SMF\s0 time field are discarded.  Since this
module cannot be aware of the time zone on the source mainframe, the
time value is treated as if it were \s-1UTC\s0 (\s-1GMT\s0).  You may have to
adjust the time accordingly; for instance, if your source mainframe
is running on Eastern time, you will probably want to add
18000 (= 5 hours * 3600 sec/hr) to the result after unpacking.
.Sp
The maximum length of a packed field is 16 bytes; of a zoned field, 32
bytes.  All other fields may have a maximum specifier (length or repeat
count) of 32767.  These maxima are enforced.
.Sp
In most cases, you should use 'i' rather than 'I' when unpacking
fullword integers.  Unsigned long integers are not handled cleanly by
all systems.
.IP "\fBhexdump\fR \s-1STRING\s0 [\s-1STARTADDR\s0 [\s-1CHARSET\s0]]" 2
.IX Item "hexdump STRING [STARTADDR [CHARSET]]"
Generates a hexadecimal dump of \s-1STRING\s0.  The dump is similar to a
\&\s-1SYSABEND\s0 dump in \s-1MVS:\s0 each line contains an address, 32 bytes of data
in hexadecimal, and the same data in printable form.  This function
returns a list of lines, each of which is terminated with a newline.
This allows them to be printed immediately; for instance, you can say
\&\*(L"print hexdump($crud);\*(R".
.Sp
The second and third arguments are optional.  The second specifies 
a starting address for the dump (default = 0); the third specifies
the character set to use for the printable data at the end of each
line (\*(L"ascii\*(R" or \*(L"ebcdic\*(R", in upper or lower case; default = ascii).
.IP "\fBversion\fR" 2
.IX Item "version"
Returns a string identifying the version of this module.  This
function is not exported; it must be called as
\&\f(CW\*(C`Convert::IBM390::version\*(C'\fR.
.SH "A COBOL EXAMPLE"
.IX Header "A COBOL EXAMPLE"
Suppose you have a mainframe record described thus in Cobol:
.PP
.Vb 17
\& 01  ACPDB-RECORD.
\&     03  ACPDB-FIRST-DATE-TRANS.
\&         05  ACPDB-FD-TRANS-CN   PIC XX.
\&         05  ACPDB-FD-TRANS-YR   PIC XX.
\&         05  ACPDB-FD-TRANS-MO   PIC XX.
\&         05  ACPDB-FD-TRANS-DA   PIC XX.
\&     03  ACPDB-LAST-DATE-TRANS.
\&         05  ACPDB-LD-TRANS-CN   PIC XX.
\&         05  ACPDB-LD-TRANS-YR   PIC XX.
\&         05  ACPDB-LD-TRANS-MO   PIC XX.
\&         05  ACPDB-LD-TRANS-DA   PIC XX.
\&     03  ACPDB-TOTAL-ITEMS       PIC S9(9)       COMP.
\&     03  ACPDB-TOTAL-NO-TRANS    PIC S9(5)       COMP-3.
\&     03  ACPDB-TOTAL-DOLLARS-1   PIC S9(7)V99    COMP-3.
\&     03  ACPDB-PREV-YR-DOLLARS   PIC S9(7)V99    COMP-3.
\&     03  ACPDB-RETURNED-ITEMS    PIC S9(4)       COMP.
\&     03  ACPDB-DOLL-CD-PREV-BASE PIC XX.
.Ve
.PP
You would unpack the record like this:
.PP
.Vb 1
\&  @fields = unpackeb('e8 e8 i p3.0 p5.2 p5.2 s e2', $inrecord)
.Ve
.SH "REFERENCES"
.IX Header "REFERENCES"
\&\s-1IBM\s0 \s-1ESA/390\s0 Principles of Operation, \s-1SA22\-7201\s0.
.PP
\&\s-1IBM\s0 System/370 Principles of Operation, \s-1GA22\-7000\s0.
.PP
\&\s-1IBM\s0 C/\*(C+ for \s-1MVS/ESA\s0 V3R2 Programming Guide, \s-1SC09\-2164\s0.
.PP
z/OS \s-1MVS\s0 System Management Facilities (\s-1SMF\s0), \s-1SA22\-7630\s0,
s.v. \*(L"Standard \s-1SMF\s0 Record Header\*(R".
.SH "BUGS"
.IX Header "BUGS"
None, of course.  What do you think this is \*(-- Unix?
.SH "AUTHOR"
.IX Header "AUTHOR"
Convert::IBM390 was written by Geoffrey Rommel
<GROMMEL@cpan.org>
in January 1999.
Thanks to Barry Roomberg for the Cobol example.
