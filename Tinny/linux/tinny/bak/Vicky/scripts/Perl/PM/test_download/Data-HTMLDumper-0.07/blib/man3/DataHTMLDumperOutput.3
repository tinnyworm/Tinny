.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTMLDumper::Output 3"
.TH HTMLDumper::Output 3 "2004-10-07" "perl v5.8.2" "User Contributed Perl Documentation"
.SH "NAME"
Data::HTMLDumper::Output \- Provides the default output for Data::HTMLDumper
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Data::HTMLDumper;
\&    # This module will become your output formatter.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is not a class you need to use directly, but if you want to control
what the output of Data::HTMLDumper looks like it will interest you.
.PP
Data::HTMLDumper uses Parse::RecDescent to parse the output of Data::Dumper.
At most stages, when its productions match corresponding methods of this
class are called.  Those methods are listed below.  By subclassing this
class and overriding methods, you can control the output's appearance.
You can achieve the same thing by replacing the class outright.  In either
case, you must tell Data::HTMLDumper by calling its actions method:
.PP
.Vb 2
\&    my $your_action_object = YourSubclass->new();
\&    Data::HTMLDumper->actions($your_action_object);
.Ve
.PP
By using objects, you can save your own state, though this class does not.
.SH "METHODS"
.IX Header "METHODS"
The following methods are available to generate output.  The are described
with lists of their parameters and samples of their output.  In all cases
(except the constructor), the first argument is the invocant, which is not
listed.
.Sh "new"
.IX Subsection "new"
This method is useful only for subclasses which do not need to save state.
It blesses a scalar reference.  It only exists so that object oriented
access is possible.
.Sh "output"
.IX Subsection "output"
This is called once each time the top level rule matches.  It receives an
array reference pointing to the text for each expression that matched.  It
is here to serve calls to Dumper which have multiple references.
Mine just interpolates the array into a string (after locally setting
$\*(L" to \*(R"").
.Sh "expression"
.IX Subsection "expression"
This method is called when the top level rule matches.  It receives the
invocant plus a hash of consumed text from the input.  The keys in the hash
are \s-1SIGIL\s0 (usually, or perhaps always, $), \s-1ID_NAME\s0 (the name of the var
as in \s-1VAR3\s0), and item (which is the text produced by the methods below
for the rest of the expression).
.PP
My version looks like this:
.PP
.Vb 3
\&  sub expression {
\&    my $self = shift;
\&    my %item = @_;
.Ve
.PP
.Vb 2
\&    return "<table border='1'>$item{item}</table>\en";
\&  }
.Ve
.PP
I won't show any more whole methods, but this shows how easy it is to
generate the output.  Simply use the input data to build a string.
Return that string.
.SH "item_value"
.IX Header "item_value"
This should probably be item_simple_value, but I didn't want to type
that everywhere.  It receives two things: a simple item (like a string, a
number, or undef) and a flag telling the item is a hash value or not
(true means it is, undefined means it's not).
.Sh "item_array"
.IX Subsection "item_array"
This is called when an entire array is seen.  Usually the output is
already generated, so my routine simply returns its second argument.
.Sh "item_hash"
.IX Subsection "item_hash"
This is just like item_array, but for hashes.  Again, all I do is return
the second argument.
.Sh "item_object"
.IX Subsection "item_object"
This is the third and final in the series.  It receives the object text.
Mine returns the second argument.
.Sh "array"
.IX Subsection "array"
This is called with an array reference listing the output for the items
which are the elements of an array.  Mine puts them in a row:
.PP
.Vb 1
\&    <tr>@$array</tr>
.Ve
.PP
Remember that it receives an array reference.
.Sh "array_empty"
.IX Subsection "array_empty"
This is called without arguments when an array of the form [] is seen.
Do what you like.  I give back this:
.PP
.Vb 1
\&    <tr><td>NO_ELEMENTS</td></tr>
.Ve
.Sh "hash"
.IX Subsection "hash"
This is like array above, but it recieves an array of the output for the
key/value pairs in the hash.  I just stringify it:
.PP
.Vb 1
\&    "@$pairs\en";
.Ve
.PP
(but I reset $\*(L" locally to \*(R"", so no extra spaces separate the entries)
.Sh "hash_empty"
.IX Subsection "hash_empty"
This is just like array_empty except for hashes like {}.  I return:
.PP
.Vb 1
\&    <tr><td>NO_PAIRS</td></tr>
.Ve
.Sh "pair"
.IX Subsection "pair"
This is called with a key and its value item, each time a pair is seen in
a hash.  My output creates a new row (since this is a whole hash), putting
the key in the first column and a table around the value in the second.
.Sh "object"
.IX Subsection "object"
This is called when a blessed reference is found.  It receives the object
and the class into which it is blessed.
.Sh "string"
.IX Subsection "string"
This is called whenever a string value is seen.  The string is passed
in.  For \s-1HTML\s0 output it is wise to replace any html characters with
their appropriate entities, for example:
.PP
.Vb 1
\&    $text    =~ s/&/&amp;/g;
.Ve
.PP
After several such substitutions, I return the string.
