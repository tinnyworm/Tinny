/*
 * FILE : gdchart_wrap.c
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : PERL 5 */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#undef free
#undef malloc
#include <string.h>
#ifdef __cplusplus
}
#endif
/* Definitions for compiling Perl extensions on a variety of machines */

#if defined(WIN32) || defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerl *pPerl = (CPerl *) this;
#define MAGIC_CAST   (int (CPerl::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif


/*****************************************************************************
 * $Header: /home/beazley/SWIG/SWIG1.1b3/swig_lib/perl5/RCS/perl5ptr.swg,v 1.1 1996/12/26 22:17:29 beazley Exp beazley $
 *
 * perl5ptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is only used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer.
 *
 * char * SWIG_GetPtr(SV *obj, void **ptr, char *type)
 *
 *      Gets a pointer value from a Perl5 scalar value.  If there is a 
 *      type-mismatch, returns a character string to the received type.  
 *      On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *
 * $Log: perl5ptr.swg,v $
 * Revision 1.1  1996/12/26 22:17:29  beazley
 * Initial revision
 *
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

/* These are internal variables.   Should be static */

typedef struct SwigPtrType {
  char               *name;
  int                 len;
  void               *(*cast)(void *);
  struct SwigPtrType *next;
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */
static int SwigStart[256];             /* Table containing starting positions    */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

#ifndef PERL_OBJECT
SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {
#else
SWIGSTATIC
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl, a,b,c)
void _SWIG_RegisterMapping(CPerl *pPerl, char *origtype, char *newtype, void *(*cast)(void *)) {
#endif

  int i;
  SwigPtrType *t = 0, *t1;

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc(SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }
  while (t->next) {
    if (strcmp(t->name,newtype) == 0) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;
  t->next = t1;
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGSTATIC 
char *SWIG_GetPtr(SV *sv, void **ptr, char *_t)
#else
SWIGSTATIC
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
char *_SWIG_GetPtr(CPerl *pPerl, SV *sv, void **ptr, char *_t)
#endif
{
  char temp_type[256];
  char *name,*_c;
  int  len,i,start,end;
  IV   tmp;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;

  /* If magical, apply more magic */

  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return "Not a valid pointer value";
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return (char *) 0;
    }
  } else if (sv == &sv_undef) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return (char *) 0;
  } else if (SvTYPE(sv) == SVt_RV) {       /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return (char *) 0;
    else
      return "Not a valid pointer value";
  } else {                                 /* Don't know what it is */
      *(ptr) = (void *) 0;
      return "Not a valid pointer value";
  }
  if (_t) {
    /* Now see if the types match */      

    if (!sv_isa(sv,_t)) {
      _c = HvNAME(SvSTASH(SvRV(sv)));
      if (!SwigPtrSort) {
	qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);  
	for (i = 0; i < 256; i++) {
	  SwigStart[i] = SwigPtrN;
	}
	for (i = SwigPtrN-1; i >= 0; i--) {
	  SwigStart[SwigPtrTable[i].name[0]] = i;
	}
	for (i = 255; i >= 1; i--) {
	  if (SwigStart[i-1] > SwigStart[i])
	    SwigStart[i-1] = SwigStart[i];
	}
	SwigPtrSort = 1;
	for (i = 0; i < SWIG_CACHESIZE; i++)  
	  SwigCache[i].stat = 0;
      }
      /* First check cache for matches.  Uses last cache value as starting point */
      cache = &SwigCache[SwigLastCache];
      for (i = 0; i < SWIG_CACHESIZE; i++) {
	if (cache->stat) {
	  if (strcmp(_t,cache->name) == 0) {
	    if (strcmp(_c,cache->mapped) == 0) {
	      cache->stat++;
	      *ptr = (void *) tmp;
	      if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
	      return (char *) 0;
	    }
	  }
	}
	SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	if (!SwigLastCache) cache = SwigCache;
	else cache++;
      }

      start = SwigStart[_t[0]];
      end = SwigStart[_t[0]+1];
      sp = &SwigPtrTable[start];
      while (start < end) {
	if (swigcmp(_t,sp) == 0) break;
	sp++;
	start++;
      }
      if (start >= end) sp = 0;
      if (sp) {
	while (swigcmp(_t,sp) == 0) {
	  name = sp->name;
	  len = sp->len;
	  tp = sp->next;
	  while(tp) {
	    if (tp->len >= 255) {
	      return _c;
	    }
	    strcpy(temp_type,tp->name);
	    strncat(temp_type,_t+len,255-tp->len);
	    if (sv_isa(sv,temp_type)) {
	      /* Get pointer value */
	      *ptr = (void *) tmp;
	      if (tp->cast) *ptr = (*(tp->cast))(*ptr);

	      strcpy(SwigCache[SwigCacheIndex].mapped,_c);
	      strcpy(SwigCache[SwigCacheIndex].name,_t);
	      SwigCache[SwigCacheIndex].stat = 1;
	      SwigCache[SwigCacheIndex].tp = tp;
	      SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
	      return (char *) 0;
	    }
	    tp = tp->next;
	  } 
	  /* Hmmm. Didn't find it this time */
 	  sp++;
	}
      }
      /* Didn't find any sort of match for this data.  
	 Get the pointer value and return the received type */
      *ptr = (void *) tmp;
      return _c;
    } else {
      /* Found a match on the first try.  Return pointer value */
      *ptr = (void *) tmp;
      return (char *) 0;
    }
  } 
  *ptr = (void *) tmp;
  return (char *) 0;
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr
/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerl *pPerl, SV *sv, char *name, int (CPerl::*set)(SV *, MAGIC *), int (CPerl::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#define SWIG_init    boot_gdchart

#define SWIG_name   "gdchart::boot_gdchart"
#define SWIG_varinit "gdchart::var_gdchart_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
SWIGEXPORT(void,boot_gdchart)(CV* cv);
#else
SWIGEXPORT(void,boot_gdchart)(CPerl *, CV *cv);
#endif


#ifdef WIN32
#undef isspace
#define isspace(c) (c == ' ')
#endif

/*------------------------------------------------------------------
  ptrcast(value,type)

  Constructs a new pointer value.   Value may either be a string
  or an integer. Type is a string corresponding to either the
  C datatype or mangled datatype.

  ptrcast(0,"Vector *")
               or
  ptrcast(0,"Vector_p")   
  ------------------------------------------------------------------ */
#ifdef PERL_OBJECT
static SV *_ptrcast(CPerl *pPerl, SV *_PTRVALUE, char *type) {
#define ptrcast(a,b)  _ptrcast(pPerl,a,b)
#else
static SV *_ptrcast(SV *_PTRVALUE, char *type) {
#define ptrcast(a,b)  _ptrcast(a,b)
#endif
  char *r,*s;
  void *ptr;
  SV *obj;
  char *typestr,*c;

  /* Produce a "mangled" version of the type string.  */

  typestr = (char *) malloc(strlen(type)+20);

  /* Go through and munge the typestring */
  
  r = typestr;
  c = type;
  while (*c) {
    if (!isspace(*c)) {
      if ((*c == '*') || (*c == '&')) {
	strcpy(r,"Ptr");
	r+=3;
      } else *(r++) = *c;
    } 
    c++;
  }
  *(r++) = 0;
    
  /* Check to see if the input value is an integer */
  if (SvIOK(_PTRVALUE)) {
    ptr = (void *) SvIV(_PTRVALUE);
    /* Received a numerical value. Make a pointer out of it */
    obj = sv_newmortal();
    sv_setref_pv(obj,typestr,ptr);
  } else if (sv_isobject(_PTRVALUE)) {
    /* Have a real pointer value now.  Try to strip out the pointer value */
    /* Now extract the pointer value */
    if (!SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
      obj = sv_newmortal();
      sv_setref_pv(obj,typestr,ptr);
    }
  } else {
    croak("ptrcast(). Not a reference.");
  }
  free(typestr);
  return obj;
}



/*------------------------------------------------------------------
  ptrvalue(ptr,type = 0)

  Attempts to dereference a pointer value.  If type is given, it 
  will try to use that type.  Otherwise, this function will attempt
  to "guess" the proper datatype by checking against all of the 
  builtin C datatypes. 
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static SV *_ptrvalue(CPerl *pPerl,SV *_PTRVALUE, int index, char *type) {
#define ptrvalue(a,b,c) _ptrvalue(pPerl,a,b,c)
#else
static SV *_ptrvalue(SV *_PTRVALUE, int index, char *type) {
#define ptrvalue(a,b,c) _ptrvalue(a,b,c)
#endif

  void     *ptr;
  SV       *obj = 0;


  if (SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    croak("Type error it ptrvalue. Argument is not a valid pointer value.");
  } else {
    /* If no datatype was passed, try a few common datatypes first */
    if (!type) {

      /* No datatype was passed.   Type to figure out if it's a common one */
      
      if (!SWIG_GetPtr(_PTRVALUE,&ptr,"intPtr")) {
	type = "int";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"doublePtr")) {
	type = "double";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"shortPtr")) {
	type = "short";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"longPtr")) {
	type = "long";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"floatPtr")) {
	type = "float";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtr")) {
	type = "char";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtrPtr")) {
	type = "char *";
      } else {
	type = "unknown";
      }
    }
    
    if (!ptr) {
      croak("Unable to dereference NULL pointer.");
      return 0;
    }

    /* Now we have a datatype.  Try to figure out what to do about it */
    if (strcmp(type,"int") == 0) {
      obj = sv_newmortal();
      sv_setiv(obj,(IV) *(((int *) ptr) + index));
    } else if (strcmp(type,"double") == 0) {
      obj = sv_newmortal();
      sv_setnv(obj,(double) *(((double *) ptr)+index));
    } else if (strcmp(type,"short") == 0) {
      obj = sv_newmortal();
      sv_setiv(obj,(IV) *(((short *) ptr) + index));
    } else if (strcmp(type,"long") == 0) {
      obj = sv_newmortal();
      sv_setiv(obj,(IV) *(((long *) ptr) + index));
    } else if (strcmp(type,"float") == 0) {
      obj = sv_newmortal();
      sv_setnv(obj,(double) *(((float *) ptr)+index));
    } else if (strcmp(type,"char") == 0) {
      obj = sv_newmortal();
      sv_setpv(obj,((char *) ptr)+index);
    } else if (strcmp(type,"char *") == 0) {
      char *c = *(((char **) ptr)+index);
      obj = sv_newmortal();
      if (c) 
	sv_setpv(obj,c);
      else 
	sv_setpv(obj,"NULL");
    } else {
      croak("Unable to dereference unsupported datatype.");
      obj = 0;
    }
  }
  return obj;
}

/*------------------------------------------------------------------
  ptrcreate(type,value = 0,numelements = 1)

  Attempts to create a new object of given type.  Type must be
  a basic C datatype.  Will not create complex objects.
  ------------------------------------------------------------------ */
#ifdef PERL_OBJECT
static SV *_ptrcreate(CPerl *pPerl, char *type, SV *value, int numelements) {
#define ptrcreate(a,b,c) _ptrcreate(pPerl,a,b,c)
#else
static SV *_ptrcreate(char *type, SV *value, int numelements) {
#define ptrcreate(a,b,c) _ptrcreate(a,b,c)
#endif

  void     *ptr;
  SV       *obj;
  int       sz;
  char     *cast;
  char      temp[40];

  /* Check the type string against a variety of possibilities */

  if (strcmp(type,"int") == 0) {
    sz = sizeof(int)*numelements;
    cast = "intPtr";
  } else if (strcmp(type,"short") == 0) {
    sz = sizeof(short)*numelements;
    cast = "shortPtr";
  } else if (strcmp(type,"long") == 0) {
    sz = sizeof(long)*numelements;
    cast = "longPtr";
  } else if (strcmp(type,"double") == 0) {
    sz = sizeof(double)*numelements;
    cast = "doublePtr";
  } else if (strcmp(type,"float") == 0) {
    sz = sizeof(float)*numelements;
    cast = "floatPtr";
  } else if (strcmp(type,"char") == 0) {
    sz = sizeof(char)*numelements;
    cast = "charPtr";
  } else if (strcmp(type,"char *") == 0) {
    sz = sizeof(char *)*(numelements+1);
    cast = "charPtrPtr";
  } else if (strcmp(type,"void") == 0) {
    sz = numelements;
    cast = "voidPtr";
  } else {
    croak("Unable to create unknown datatype."); 
    return 0;
  }
   
  /* Create the new object */
  
  ptr = (void *) malloc(sz);
  if (!ptr) {
    croak("Out of memory in ptrcreate."); 
    return 0;
  }

  /* Now try to set its default value */

  if (value) {
    if (strcmp(type,"int") == 0) {
      int *ip,i,ivalue;
      ivalue = (int) SvIV(value);
      ip = (int *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"short") == 0) {
      short *ip,ivalue;
      int i;
      ivalue = (short) SvIV(value);
      ip = (short *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"long") == 0) {
      long *ip,ivalue;
      int i;
      ivalue = (long) SvIV(value);
      ip = (long *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"double") == 0) {
      double *ip,ivalue;
      int i;
      ivalue = (double) SvNV(value);
      ip = (double *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"float") == 0) {
      float *ip,ivalue;
      int i;
      ivalue = (float) SvNV(value);
      ip = (float *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"char") == 0) {
      char *ip,*ivalue;
      ivalue = (char *) SvPV(value,na);
      ip = (char *) ptr;
      strncpy(ip,ivalue,numelements-1);
    } else if (strcmp(type,"char *") == 0) {
      char **ip, *ivalue;
      int  i;
      ivalue = (char *) SvPV(value,na);
      ip = (char **) ptr;
      for (i = 0; i < numelements; i++) {
	if (ivalue) {
	  ip[i] = (char *) malloc(strlen(ivalue)+1);
	  strcpy(ip[i],ivalue);
	} else {
	  ip[i] = 0;
	}
      }
      ip[numelements] = 0;
    }
  } 
  /* Create the pointer value */
  
  SWIG_MakePtr(temp,ptr,cast);
  obj = sv_newmortal();
  sv_setref_pv(obj,cast,ptr);
  return obj;
}

/*------------------------------------------------------------------
  ptrset(ptr,value,index = 0,type = 0)

  Attempts to set the value of a pointer variable.  If type is
  given, we will use that type.  Otherwise, we'll guess the datatype.
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static void _ptrset(CPerl *pPerl,SV *_PTRVALUE, SV *value, int index, char *type) {
#define ptrset(a,b,c,d) _ptrset(pPerl,a,b,c,d)
#else
static void _ptrset(SV *_PTRVALUE, SV *value, int index, char *type) {
#define ptrset(a,b,c,d) _ptrset(a,b,c,d)
#endif
  void     *ptr;
  SV       *obj;

  if (SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    croak("Type error in ptrset. Argument is not a valid pointer value.");
    return;
  }

  /* If no datatype was passed, try a few common datatypes first */

  if (!type) {

    /* No datatype was passed.   Type to figure out if it's a common one */

    if (!SWIG_GetPtr(_PTRVALUE,&ptr,"intPtr")) {
      type = "int";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"doublePtr")) {
      type = "double";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"shortPtr")) {
      type = "short";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"longPtr")) {
      type = "long";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"floatPtr")) {
      type = "float";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtr")) {
      type = "char";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtrPtr")) {
      type = "char *";
    } else {
      type = "unknown";
    }
  }

  if (!ptr) {
    croak("Unable to set NULL pointer.");
    return;
  }
  
  /* Now we have a datatype.  Try to figure out what to do about it */
  if (strcmp(type,"int") == 0) {
    *(((int *) ptr)+index) = (int) SvIV(value);
  } else if (strcmp(type,"double") == 0) {
    *(((double *) ptr)+index) = (double) SvNV(value);
  } else if (strcmp(type,"short") == 0) {
    *(((short *) ptr)+index) = (short) SvIV(value);
  } else if (strcmp(type,"long") == 0) {
    *(((long *) ptr)+index) = (long) SvIV(value);
  } else if (strcmp(type,"float") == 0) {
    *(((float *) ptr)+index) = (float) SvNV(value);
  } else if (strcmp(type,"char") == 0) {
    char *c = SvPV(value,na);
    strcpy(((char *) ptr)+index, c);
  } else if (strcmp(type,"char *") == 0) {
    char *c = SvPV(value,na);
    char **ca = (char **) ptr;
    if (ca[index]) free(ca[index]);
    if (strcmp(c,"NULL") == 0) {
      ca[index] = 0;
    } else {
      ca[index] = (char *) malloc(strlen(c)+1);
      strcpy(ca[index],c);
    }
  } else {
    croak("Unable to set unsupported datatype.");
    return;
  }
}

/*------------------------------------------------------------------
  ptradd(ptr,offset)

  Adds a value to an existing pointer value.  Will do a type-dependent
  add for basic datatypes.  For other datatypes, will do a byte-add.
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static SV *_ptradd(CPerl *pPerl, SV *_PTRVALUE, int offset) {
#define ptradd(a,b) _ptradd(pPerl,a,b)
#else
static SV *_ptradd(SV *_PTRVALUE, int offset) {
#define ptradd(a,b) _ptradd(a,b)
#endif

  void *ptr,*junk;
  SV   *obj;
  char *type;

  /* Try to handle a few common datatypes first */

  if (!SWIG_GetPtr(_PTRVALUE,&ptr,"intPtr")) {
    ptr = (void *) (((int *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"doublePtr")) {
    ptr = (void *) (((double *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"shortPtr")) {
    ptr = (void *) (((short *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"longPtr")) {
    ptr = (void *) (((long *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"floatPtr")) {
    ptr = (void *) (((float *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtr")) {
    ptr = (void *) (((char *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    ptr = (void *) (((char *) ptr) + offset);
  } else {
    croak("Type error in ptradd. Argument is not a valid pointer value.");
    return 0;
  }
  type = SWIG_GetPtr(_PTRVALUE,&junk,"INVALID POINTER");
  obj = sv_newmortal();
  sv_setref_pv(obj,type,ptr);
  return obj;
}

/*------------------------------------------------------------------
  ptrmap(type1,type2)

  Allows a mapping between type1 and type2. (Like a typedef)
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static void _ptrmap(CPerl *pPerl,char *type1, char *type2) {
#define ptrmap(a,b) _ptrmap(pPerl,a,b)
#else
static void _ptrmap(char *type1, char *type2) {
#define ptrmap(a,b) _ptrmap(a,b)
#endif
  char *typestr1,*typestr2,*c,*r;
  /* Produce a "mangled" version of the type string.  */

  typestr1 = (char *) malloc(strlen(type1)+20);


  /* Go through and munge the typestring */
  
  r = typestr1;
  *(r++) = '_';
  c = type1;

  while (*c) {
    if (!isspace(*c)) {
      if ((*c == '*') || (*c == '&')) {
	strcpy(r,"Ptr");
	r+=3;
      }
      else *(r++) = *c;
    } 
    c++;
  }
  *(r++) = 0;

  typestr2 = (char *) malloc(strlen(type2)+20);

  /* Go through and munge the typestring */
  
  r = typestr2;
  *(r++) = '_';
  c = type2;
  while (*c) {
    if (!isspace(*c)) {
      if ((*c == '*') || (*c == '&')) {
	strcpy(r,"Ptr");
	r+=3;
      }
      else *(r++) = *c;
    }
    c++;
  }
  *(r++) = 0;
  SWIG_RegisterMapping(typestr1,typestr2,0);
  SWIG_RegisterMapping(typestr2,typestr1,0);
}

/*------------------------------------------------------------------
  ptrfree(ptr)

  Destroys a pointer value
  ------------------------------------------------------------------ */
#ifdef PERL_OBJECT
void _ptrfree(CPerl *pPerl, SV *_PTRVALUE) {
#define ptrfree(a) _ptrfree(pPerl, a)
#else
void _ptrfree(SV *_PTRVALUE) {
#define ptrfree(a) _ptrfree(a)
#endif

  void *ptr, *junk;

  if (SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    croak("Type error in ptrfree. Argument is not a valid pointer value.");
    return;
  }

  /* Check to see if this pointer is a char ** */
  if (!SWIG_GetPtr(_PTRVALUE,&junk,"charPtrPtr")) {
    char **c = (char **) ptr;
    if (c) {
      int i = 0;
      while (c[i]) {
	free(c[i]);
	i++;
      }
    }
  } 
  if (ptr)
    free((char *) ptr);
}



#include <stdio.h>
#include <values.h>
#include "gdc.h"
#include "gdcpie.h"
#include "gdchart.h"

extern void set_vars (
        int perl_GDC_stack_type,
        char *perl_GDC_title,
        char *perl_GDC_xtitle,
        char *perl_GDC_ytitle,
        char *perl_GDC_ytitle2,
        int perl_GDC_title_size,
        int perl_GDC_xtitle_size,
        int perl_GDC_ytitle_size,
        float perl_GDC_3d_depth,
        unsigned char perl_GDC_3d_angle,
        unsigned char perl_GDC_bar_width,
        unsigned long perl_GDC_BGColor,
        unsigned long perl_GDC_TitleColor,
        unsigned long perl_GDC_GridColor,
        unsigned long perl_GDC_LineColor,
        unsigned long perl_GDC_PlotColor,
        unsigned long perl_GDC_VolColor,
        unsigned long perl_GDC_XTitleColor,
        unsigned long perl_GDC_YTitleColor,
        unsigned long perl_GDC_YTitle2Color,
        unsigned long perl_GDC_XLabelColor,
        unsigned long perl_GDC_YLabelColor,
        unsigned long perl_GDC_YLabel2Color,
        int perl_GDC_grid,
        int perl_GDC_xaxis,
        int perl_GDC_yaxis,
        int perl_GDC_yaxis2,
        int perl_GDC_border,
        float perl_GDC_requested_ymin,
        float perl_GDC_requested_ymax,
        float perl_GDC_requested_yinterval,
        float perl_GDC_ylabel_density,
        int perl_GDC_HLC_style,
        int perl_GDC_HLC_cap_width,
        char * perl_GDC_ylabel_fmt,
	long perl_GDC_ExtColor [],
	char * perl_GDC_BGImage)   {

GDC_stack_type=perl_GDC_stack_type;
GDC_title=perl_GDC_title;
GDC_ytitle=perl_GDC_ytitle;
GDC_ytitle2=perl_GDC_ytitle2;
GDC_xtitle=perl_GDC_xtitle;
GDC_title_size=perl_GDC_title_size;
GDC_xtitle_size=perl_GDC_xtitle_size;
GDC_ytitle_size=perl_GDC_ytitle_size;
GDC_3d_depth=perl_GDC_3d_depth;
GDC_3d_angle=perl_GDC_3d_angle;
GDC_bar_width=perl_GDC_bar_width;
GDC_BGColor=perl_GDC_BGColor;
GDC_TitleColor=perl_GDC_TitleColor;
GDC_GridColor=perl_GDC_GridColor;
GDC_LineColor=perl_GDC_LineColor;
GDC_PlotColor=perl_GDC_PlotColor;
GDC_VolColor=perl_GDC_VolColor;
GDC_XTitleColor=perl_GDC_XTitleColor;
GDC_YTitleColor=perl_GDC_YTitleColor;
GDC_YTitle2Color=perl_GDC_YTitle2Color;
GDC_XLabelColor=perl_GDC_XLabelColor;
GDC_YLabelColor=perl_GDC_YLabelColor;
GDC_YLabel2Color=perl_GDC_YLabel2Color;
GDC_grid=perl_GDC_grid;
GDC_xaxis=perl_GDC_xaxis;
GDC_yaxis=perl_GDC_yaxis;
GDC_yaxis2=perl_GDC_yaxis2;
GDC_border=perl_GDC_border;
GDC_requested_ymin=perl_GDC_requested_ymin;
GDC_requested_ymax=perl_GDC_requested_ymax;
GDC_requested_yinterval=perl_GDC_requested_yinterval;
GDC_ylabel_density=perl_GDC_ylabel_density;
GDC_HLC_style=perl_GDC_HLC_style;
GDC_HLC_cap_width=perl_GDC_HLC_cap_width;
GDC_ylabel_fmt = perl_GDC_ylabel_fmt;

if ( perl_GDC_ExtColor[0] != -99999999)	{
	GDC_ExtColor = perl_GDC_ExtColor;
					}

GDC_BGImage = perl_GDC_BGImage;
}

extern void annotate (
	int perl_anno_set,
	unsigned long perl_anno_color,
	char * perl_anno_note,
	float perl_anno_point,
	int perl_anno_font )	{

static GDC_ANNOTATION_T anno;

if (perl_anno_set )     {
anno.color = perl_anno_color;
strncpy (anno.note, perl_anno_note, MAX_NOTE_LEN);
anno.point = perl_anno_point;
GDC_annotation_font = perl_anno_font;
GDC_annotation = &anno;
                        }

else { GDC_annotation = (GDC_ANNOTATION_T*)NULL; }


				}

extern void single_arg (
        int width, int height,
        char * filename,
        int numpoints,
        char * labels [],
        float dataset1 [],
        int perl_type
 )

{
FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
out_graph( width, height, ptr, perl_type, numpoints, labels, 1, dataset1 );
fclose(ptr);
}

extern void set_pievars (
        unsigned long perl_GDCPIE_BGColor,
        unsigned long perl_GDCPIE_LineColor,
        unsigned long perl_GDCPIE_PlotColor,
        unsigned long perl_GDCPIE_EdgeColor,
        char perl_GDCPIE_other_threshold,
        unsigned short perl_GDCPIE_3d_angle,
        unsigned short perl_GDCPIE_3d_depth,
        int perl_GDCPIE_title_size,
        int perl_GDCPIE_label_size,
        int perl_GDCPIE_label_dist,
        unsigned char perl_GDCPIE_label_line,
        int * perl_GDCPIE_explode,
        int * perl_GDCPIE_missing,
        int perl_GDCPIE_percent_labels,
        char * perl_GDCPIE_title
                        )

{
GDCPIE_BGColor=perl_GDCPIE_BGColor;
GDCPIE_LineColor=perl_GDCPIE_LineColor;
GDCPIE_PlotColor=perl_GDCPIE_PlotColor;
GDCPIE_EdgeColor=perl_GDCPIE_EdgeColor;
GDCPIE_other_threshold=perl_GDCPIE_other_threshold;
GDCPIE_3d_angle=perl_GDCPIE_3d_angle;
GDCPIE_3d_angle=perl_GDCPIE_3d_depth;
GDCPIE_title_size=perl_GDCPIE_title_size;
GDCPIE_label_size=perl_GDCPIE_label_size;
GDCPIE_label_dist=perl_GDCPIE_label_dist;
GDCPIE_label_line=perl_GDCPIE_label_line;
GDCPIE_explode=perl_GDCPIE_explode;
GDCPIE_missing=perl_GDCPIE_missing;
GDCPIE_percent_labels=perl_GDCPIE_percent_labels;
GDCPIE_title=perl_GDCPIE_title;

}

extern void double_arg (
        int width, int height,
        char * filename,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
out_graph( width, height, ptr, perl_type, numpoints, labels, 2, dataset1, dataset2 );
fclose(ptr);
}

extern void combo (
        int width, int height,
        char * filename,
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
out_graph( width, height, ptr, perl_type, numpoints, labels, 1, dataset1, dataset2 );
fclose(ptr);
}

extern void triple_arg (
        int width, int height,
        char * filename,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[], float dataset3[],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
out_graph( width, height, ptr, perl_type, numpoints, labels, 3,  dataset1, dataset2, dataset3 );
fclose(ptr);
}

extern void hiloclose_wrap (
        int width, int height,
        char * filename,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[], float dataset3[],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
out_graph( width, height, ptr, perl_type, numpoints, labels, 1,  dataset1, dataset2, dataset3 );
fclose(ptr);
}

extern void combo_hiloclose_wrap (
        int width, int height,
        char * filename,
        long perl_GDC_Axis2Col,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[], float dataset3[],
        float dataset4 [],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
GDC_VolColor=perl_GDC_Axis2Col;
out_graph( width, height, ptr, perl_type, numpoints, labels, 1,  dataset1, dataset2, dataset3, dataset4 );
fclose(ptr);
}

extern void gd_pie_graph        (
        int width, int height,
        char * filename,
        int pie_type,
        long perl_GDC_pie_color [],
        int numpoints,
        char * labels[],
        float dataset1 []               )

{

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDCPIE_Color=perl_GDC_pie_color;
pie_gif (width, height, ptr, pie_type, numpoints, labels, dataset1);
fclose(ptr);
}

extern void four_arg (
        int width, int height,
        char * filename,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[], float dataset3[], float dataset4[],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
out_graph( width, height, ptr, perl_type, numpoints, labels, 4,  dataset1, dataset2, dataset3, dataset4 );
fclose(ptr);
}


extern void five_arg (
        int width, int height,
        char * filename,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[], float dataset3[], float dataset4[], float dataset5[],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
out_graph( width, height, ptr, perl_type, numpoints, labels, 5,  dataset1, dataset2, dataset3, dataset4, dataset5 );
fclose(ptr);
}


extern void six_arg (
        int width, int height,
        char * filename,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[], float dataset3[], float dataset4[], float dataset5[], float dataset6[],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
out_graph( width, height, ptr, perl_type, numpoints, labels, 6,  dataset1, dataset2, dataset3, dataset4, dataset5,
	 dataset6 );
fclose(ptr);
}


extern void seven_arg (
        int width, int height,
        char * filename,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[], float dataset3[], float dataset4[], float dataset5[], float dataset6[],
	float dataset7 [],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
out_graph( width, height, ptr, perl_type, numpoints, labels, 7,  dataset1, dataset2, dataset3, dataset4, dataset5,
	 dataset6, dataset7  );
fclose(ptr);
}


extern void eight_arg (
        int width, int height,
        char * filename,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[], float dataset3[], float dataset4[], float dataset5[], float dataset6[],
	float dataset7 [], float dataset8 [],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
out_graph( width, height, ptr, perl_type, numpoints, labels, 8,  dataset1, dataset2, dataset3, dataset4, dataset5,
	 dataset6, dataset7, dataset8   );
fclose(ptr);
}


extern void nine_arg (
        int width, int height,
        char * filename,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[], float dataset3[], float dataset4[], float dataset5[], float dataset6[],
	float dataset7 [], float dataset8 [], float dataset9 [],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
out_graph( width, height, ptr, perl_type, numpoints, labels, 9,  dataset1, dataset2, dataset3, dataset4, dataset5,
	 dataset6, dataset7, dataset8, dataset9      );
fclose(ptr);
}


extern void ten_arg (
        int width, int height,
        char * filename,
        long perl_GDC_SetColor [],
        int numpoints,
        char * labels [],
        float dataset1 [], float dataset2[], float dataset3[], float dataset4[], float dataset5[], float dataset6[],
	float dataset7 [], float dataset8 [], float dataset9 [], float dataset10 [],
        int perl_type ) {

FILE *ptr = (FILE*)NULL;

if (filename != NULL && strcmp (filename, "STDOUT") == 0)       {
        ptr = stdout;
                                }

else                            {
        ptr = fopen (filename, "wb");
                                }

if (ptr == NULL)        {
        printf ("Unable to open %s", filename);
        exit (0);
                        }
GDC_SetColor=perl_GDC_SetColor;
out_graph( width, height, ptr, perl_type, numpoints, labels, 10,  dataset1, dataset2, dataset3, dataset4, dataset5,
	 dataset6, dataset7, dataset8, dataset9, dataset10      );
fclose(ptr);
}

extern void set_vars(int ,char *,char *,char *,char *,int ,int ,int ,float ,unsigned char ,unsigned char ,unsigned long ,unsigned long ,unsigned long ,unsigned long ,unsigned long ,unsigned long ,unsigned long ,unsigned long ,unsigned long ,unsigned long ,unsigned long ,unsigned long ,int ,int ,int ,int ,int ,float ,float ,float ,float ,int ,int ,char *,long [],char *);
extern void annotate(int ,unsigned long ,char *,float ,int );
extern void single_arg(int ,int ,char *,int ,char *[],float [],int );
extern void set_pievars(unsigned long ,unsigned long ,unsigned long ,unsigned long ,char ,unsigned short ,unsigned short ,int ,int ,int ,unsigned char ,int *,int *,int ,char *);
extern void double_arg(int ,int ,char *,long [],int ,char *[],float [],float [],int );
extern void combo(int ,int ,char *,int ,char *[],float [],float [],int );
extern void triple_arg(int ,int ,char *,long [],int ,char *[],float [],float [],float [],int );
extern void hiloclose_wrap(int ,int ,char *,long [],int ,char *[],float [],float [],float [],int );
extern void combo_hiloclose_wrap(int ,int ,char *,long ,long [],int ,char *[],float [],float [],float [],float [],int );
extern void gd_pie_graph(int ,int ,char *,int ,long [],int ,char *[],float []);
extern void four_arg(int ,int ,char *,long [],int ,char *[],float [],float [],float [],float [],int );
extern void five_arg(int ,int ,char *,long [],int ,char *[],float [],float [],float [],float [],float [],int );
extern void six_arg(int ,int ,char *,long [],int ,char *[],float [],float [],float [],float [],float [],float [],int );
extern void seven_arg(int ,int ,char *,long [],int ,char *[],float [],float [],float [],float [],float [],float [],float [],int );
extern void eight_arg(int ,int ,char *,long [],int ,char *[],float [],float [],float [],float [],float [],float [],float [],float [],int );
extern void nine_arg(int ,int ,char *,long [],int ,char *[],float [],float [],float [],float [],float [],float [],float [],float [],float [],int );
extern void ten_arg(int ,int ,char *,long [],int ,char *[],float [],float [],float [],float [],float [],float [],float [],float [],float [],float [],int );
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_gdchart_var::
class _wrap_gdchart_var : public CPerl {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

XS(_wrap_ptrcast) {

    SV * _result;
    SV * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ptrcast(ptr,type);");
{
  _arg0 = ST(0);
}
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (SV *)ptrcast(_arg0,_arg1);
{
  ST(0) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrvalue) {

    SV * _result;
    SV * _arg0;
    int  _arg1 = 0;
    char * _arg2 = 0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 3)) 
        croak("Usage: ptrvalue(ptr,index,type);");
{
  _arg0 = ST(0);
}
    if (items > 1) {
    _arg1 = (int )SvIV(ST(1));
    } 
    if (items > 2) {
    _arg2 = (char *) SvPV(ST(2),na);
    } 
    _result = (SV *)ptrvalue(_arg0,_arg1,_arg2);
{
  ST(0) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrset) {

    SV * _arg0;
    SV * _arg1;
    int  _arg2 = 0;
    char * _arg3 = 0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 4)) 
        croak("Usage: ptrset(ptr,value,index,type);");
{
  _arg0 = ST(0);
}
{
  _arg1 = ST(1);
}
    if (items > 2) {
    _arg2 = (int )SvIV(ST(2));
    } 
    if (items > 3) {
    _arg3 = (char *) SvPV(ST(3),na);
    } 
    ptrset(_arg0,_arg1,_arg2,_arg3);
    XSRETURN(argvi);
}

XS(_wrap_ptrcreate) {

    SV * _result;
    char * _arg0;
    SV * _arg1 = 0;
    int  _arg2 = 1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 3)) 
        croak("Usage: ptrcreate(type,value,nitems);");
    _arg0 = (char *) SvPV(ST(0),na);
    if (items > 1) {
{
  _arg1 = ST(1);
}
    } 
    if (items > 2) {
    _arg2 = (int )SvIV(ST(2));
    } 
    _result = (SV *)ptrcreate(_arg0,_arg1,_arg2);
{
  ST(0) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrfree) {

    SV * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: ptrfree(ptr);");
{
  _arg0 = ST(0);
}
    ptrfree(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_ptradd) {

    SV * _result;
    SV * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ptradd(ptr,offset);");
{
  _arg0 = ST(0);
}
    _arg1 = (int )SvIV(ST(1));
    _result = (SV *)ptradd(_arg0,_arg1);
{
  ST(0) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrmap) {

    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ptrmap(type1,type2);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (char *) SvPV(ST(1),na);
    ptrmap(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_set_vars) {

    int  _arg0;
    char * _arg1;
    char * _arg2;
    char * _arg3;
    char * _arg4;
    int  _arg5;
    int  _arg6;
    int  _arg7;
    float  _arg8;
    unsigned char  _arg9;
    unsigned char  _arg10;
    unsigned long  _arg11;
    unsigned long  _arg12;
    unsigned long  _arg13;
    unsigned long  _arg14;
    unsigned long  _arg15;
    unsigned long  _arg16;
    unsigned long  _arg17;
    unsigned long  _arg18;
    unsigned long  _arg19;
    unsigned long  _arg20;
    unsigned long  _arg21;
    unsigned long  _arg22;
    int  _arg23;
    int  _arg24;
    int  _arg25;
    int  _arg26;
    int  _arg27;
    float  _arg28;
    float  _arg29;
    float  _arg30;
    float  _arg31;
    int  _arg32;
    int  _arg33;
    char * _arg34;
    long * _arg35;
    char * _arg36;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 37) || (items > 37)) 
        croak("Usage: set_vars(perl_GDC_stack_type,perl_GDC_title,perl_GDC_xtitle,perl_GDC_ytitle,perl_GDC_ytitle2,perl_GDC_title_size,perl_GDC_xtitle_size,perl_GDC_ytitle_size,perl_GDC_3d_depth,perl_GDC_3d_angle,perl_GDC_bar_width,perl_GDC_BGColor,perl_GDC_TitleColor,perl_GDC_GridColor,perl_GDC_LineColor,perl_GDC_PlotColor,perl_GDC_VolColor,perl_GDC_XTitleColor,perl_GDC_YTitleColor,perl_GDC_YTitle2Color,perl_GDC_XLabelColor,perl_GDC_YLabelColor,perl_GDC_YLabel2Color,perl_GDC_grid,perl_GDC_xaxis,perl_GDC_yaxis,perl_GDC_yaxis2,perl_GDC_border,perl_GDC_requested_ymin,perl_GDC_requested_ymax,perl_GDC_requested_yinterval,perl_GDC_ylabel_density,perl_GDC_HLC_style,perl_GDC_HLC_cap_width,perl_GDC_ylabel_fmt,perl_GDC_ExtColor,perl_GDC_BGImage);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (char *) SvPV(ST(1),na);
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (char *) SvPV(ST(3),na);
    _arg4 = (char *) SvPV(ST(4),na);
    _arg5 = (int )SvIV(ST(5));
    _arg6 = (int )SvIV(ST(6));
    _arg7 = (int )SvIV(ST(7));
    _arg8 = (float ) SvNV(ST(8));
    _arg9 = (unsigned char )SvIV(ST(9));
    _arg10 = (unsigned char )SvIV(ST(10));
    _arg11 = (unsigned long )SvIV(ST(11));
    _arg12 = (unsigned long )SvIV(ST(12));
    _arg13 = (unsigned long )SvIV(ST(13));
    _arg14 = (unsigned long )SvIV(ST(14));
    _arg15 = (unsigned long )SvIV(ST(15));
    _arg16 = (unsigned long )SvIV(ST(16));
    _arg17 = (unsigned long )SvIV(ST(17));
    _arg18 = (unsigned long )SvIV(ST(18));
    _arg19 = (unsigned long )SvIV(ST(19));
    _arg20 = (unsigned long )SvIV(ST(20));
    _arg21 = (unsigned long )SvIV(ST(21));
    _arg22 = (unsigned long )SvIV(ST(22));
    _arg23 = (int )SvIV(ST(23));
    _arg24 = (int )SvIV(ST(24));
    _arg25 = (int )SvIV(ST(25));
    _arg26 = (int )SvIV(ST(26));
    _arg27 = (int )SvIV(ST(27));
    _arg28 = (float ) SvNV(ST(28));
    _arg29 = (float ) SvNV(ST(29));
    _arg30 = (float ) SvNV(ST(30));
    _arg31 = (float ) SvNV(ST(31));
    _arg32 = (int )SvIV(ST(32));
    _arg33 = (int )SvIV(ST(33));
    _arg34 = (char *) SvPV(ST(34),na);
    if (SWIG_GetPtr(ST(35),(void **) &_arg35,"longPtr")) {
        croak("Type error in argument 36 of set_vars. Expected longPtr.");
        XSRETURN(1);
    }
    _arg36 = (char *) SvPV(ST(36),na);
    set_vars(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12,_arg13,_arg14,_arg15,_arg16,_arg17,_arg18,_arg19,_arg20,_arg21,_arg22,_arg23,_arg24,_arg25,_arg26,_arg27,_arg28,_arg29,_arg30,_arg31,_arg32,_arg33,_arg34,_arg35,_arg36);
    XSRETURN(argvi);
}

XS(_wrap_annotate) {

    int  _arg0;
    unsigned long  _arg1;
    char * _arg2;
    float  _arg3;
    int  _arg4;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 5) || (items > 5)) 
        croak("Usage: annotate(perl_anno_set,perl_anno_color,perl_anno_note,perl_anno_point,perl_anno_font);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (unsigned long )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (float ) SvNV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    annotate(_arg0,_arg1,_arg2,_arg3,_arg4);
    XSRETURN(argvi);
}

XS(_wrap_single_arg) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    int  _arg3;
    char ** _arg4;
    float * _arg5;
    int  _arg6;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 7) || (items > 7)) 
        croak("Usage: single_arg(width,height,filename,numpoints,labels,dataset1,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (int )SvIV(ST(3));
    if (SWIG_GetPtr(ST(4),(void **) &_arg4,"charPtrPtr")) {
        croak("Type error in argument 5 of single_arg. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"floatPtr")) {
        croak("Type error in argument 6 of single_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg6 = (int )SvIV(ST(6));
    single_arg(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6);
    XSRETURN(argvi);
}

XS(_wrap_set_pievars) {

    unsigned long  _arg0;
    unsigned long  _arg1;
    unsigned long  _arg2;
    unsigned long  _arg3;
    char  _arg4;
    unsigned short  _arg5;
    unsigned short  _arg6;
    int  _arg7;
    int  _arg8;
    int  _arg9;
    unsigned char  _arg10;
    int * _arg11;
    int * _arg12;
    int  _arg13;
    char * _arg14;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 15) || (items > 15)) 
        croak("Usage: set_pievars(perl_GDCPIE_BGColor,perl_GDCPIE_LineColor,perl_GDCPIE_PlotColor,perl_GDCPIE_EdgeColor,perl_GDCPIE_other_threshold,perl_GDCPIE_3d_angle,perl_GDCPIE_3d_depth,perl_GDCPIE_title_size,perl_GDCPIE_label_size,perl_GDCPIE_label_dist,perl_GDCPIE_label_line,perl_GDCPIE_explode,perl_GDCPIE_missing,perl_GDCPIE_percent_labels,perl_GDCPIE_title);");
    _arg0 = (unsigned long )SvIV(ST(0));
    _arg1 = (unsigned long )SvIV(ST(1));
    _arg2 = (unsigned long )SvIV(ST(2));
    _arg3 = (unsigned long )SvIV(ST(3));
    _arg4 = (char) *SvPV(ST(4),na);
    _arg5 = (unsigned short )SvIV(ST(5));
    _arg6 = (unsigned short )SvIV(ST(6));
    _arg7 = (int )SvIV(ST(7));
    _arg8 = (int )SvIV(ST(8));
    _arg9 = (int )SvIV(ST(9));
    _arg10 = (unsigned char )SvIV(ST(10));
    if (SWIG_GetPtr(ST(11),(void **) &_arg11,"intPtr")) {
        croak("Type error in argument 12 of set_pievars. Expected intPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(12),(void **) &_arg12,"intPtr")) {
        croak("Type error in argument 13 of set_pievars. Expected intPtr.");
        XSRETURN(1);
    }
    _arg13 = (int )SvIV(ST(13));
    _arg14 = (char *) SvPV(ST(14),na);
    set_pievars(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12,_arg13,_arg14);
    XSRETURN(argvi);
}

XS(_wrap_double_arg) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long * _arg3;
    int  _arg4;
    char ** _arg5;
    float * _arg6;
    float * _arg7;
    int  _arg8;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 9) || (items > 9)) 
        croak("Usage: double_arg(width,height,filename,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"longPtr")) {
        croak("Type error in argument 4 of double_arg. Expected longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"charPtrPtr")) {
        croak("Type error in argument 6 of double_arg. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of double_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of double_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg8 = (int )SvIV(ST(8));
    double_arg(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8);
    XSRETURN(argvi);
}

XS(_wrap_combo) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    int  _arg3;
    char ** _arg4;
    float * _arg5;
    float * _arg6;
    int  _arg7;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 8) || (items > 8)) 
        croak("Usage: combo(width,height,filename,numpoints,labels,dataset1,dataset2,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (int )SvIV(ST(3));
    if (SWIG_GetPtr(ST(4),(void **) &_arg4,"charPtrPtr")) {
        croak("Type error in argument 5 of combo. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"floatPtr")) {
        croak("Type error in argument 6 of combo. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of combo. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg7 = (int )SvIV(ST(7));
    combo(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7);
    XSRETURN(argvi);
}

XS(_wrap_triple_arg) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long * _arg3;
    int  _arg4;
    char ** _arg5;
    float * _arg6;
    float * _arg7;
    float * _arg8;
    int  _arg9;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 10) || (items > 10)) 
        croak("Usage: triple_arg(width,height,filename,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,dataset3,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"longPtr")) {
        croak("Type error in argument 4 of triple_arg. Expected longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"charPtrPtr")) {
        croak("Type error in argument 6 of triple_arg. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of triple_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of triple_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of triple_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg9 = (int )SvIV(ST(9));
    triple_arg(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9);
    XSRETURN(argvi);
}

XS(_wrap_hiloclose_wrap) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long * _arg3;
    int  _arg4;
    char ** _arg5;
    float * _arg6;
    float * _arg7;
    float * _arg8;
    int  _arg9;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 10) || (items > 10)) 
        croak("Usage: hiloclose_wrap(width,height,filename,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,dataset3,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"longPtr")) {
        croak("Type error in argument 4 of hiloclose_wrap. Expected longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"charPtrPtr")) {
        croak("Type error in argument 6 of hiloclose_wrap. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of hiloclose_wrap. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of hiloclose_wrap. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of hiloclose_wrap. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg9 = (int )SvIV(ST(9));
    hiloclose_wrap(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9);
    XSRETURN(argvi);
}

XS(_wrap_combo_hiloclose_wrap) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long  _arg3;
    long * _arg4;
    int  _arg5;
    char ** _arg6;
    float * _arg7;
    float * _arg8;
    float * _arg9;
    float * _arg10;
    int  _arg11;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 12) || (items > 12)) 
        croak("Usage: combo_hiloclose_wrap(width,height,filename,perl_GDC_Axis2Col,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,dataset3,dataset4,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (long )SvIV(ST(3));
    if (SWIG_GetPtr(ST(4),(void **) &_arg4,"longPtr")) {
        croak("Type error in argument 5 of combo_hiloclose_wrap. Expected longPtr.");
        XSRETURN(1);
    }
    _arg5 = (int )SvIV(ST(5));
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"charPtrPtr")) {
        croak("Type error in argument 7 of combo_hiloclose_wrap. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of combo_hiloclose_wrap. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of combo_hiloclose_wrap. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(9),(void **) &_arg9,"floatPtr")) {
        croak("Type error in argument 10 of combo_hiloclose_wrap. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(10),(void **) &_arg10,"floatPtr")) {
        croak("Type error in argument 11 of combo_hiloclose_wrap. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg11 = (int )SvIV(ST(11));
    combo_hiloclose_wrap(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11);
    XSRETURN(argvi);
}

XS(_wrap_gd_pie_graph) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    int  _arg3;
    long * _arg4;
    int  _arg5;
    char ** _arg6;
    float * _arg7;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 8) || (items > 8)) 
        croak("Usage: gd_pie_graph(width,height,filename,pie_type,perl_GDC_pie_color,numpoints,labels,dataset1);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (int )SvIV(ST(3));
    if (SWIG_GetPtr(ST(4),(void **) &_arg4,"longPtr")) {
        croak("Type error in argument 5 of gd_pie_graph. Expected longPtr.");
        XSRETURN(1);
    }
    _arg5 = (int )SvIV(ST(5));
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"charPtrPtr")) {
        croak("Type error in argument 7 of gd_pie_graph. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of gd_pie_graph. Expected floatPtr.");
        XSRETURN(1);
    }
    gd_pie_graph(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7);
    XSRETURN(argvi);
}

XS(_wrap_four_arg) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long * _arg3;
    int  _arg4;
    char ** _arg5;
    float * _arg6;
    float * _arg7;
    float * _arg8;
    float * _arg9;
    int  _arg10;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 11) || (items > 11)) 
        croak("Usage: four_arg(width,height,filename,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,dataset3,dataset4,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"longPtr")) {
        croak("Type error in argument 4 of four_arg. Expected longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"charPtrPtr")) {
        croak("Type error in argument 6 of four_arg. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of four_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of four_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of four_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(9),(void **) &_arg9,"floatPtr")) {
        croak("Type error in argument 10 of four_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg10 = (int )SvIV(ST(10));
    four_arg(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10);
    XSRETURN(argvi);
}

XS(_wrap_five_arg) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long * _arg3;
    int  _arg4;
    char ** _arg5;
    float * _arg6;
    float * _arg7;
    float * _arg8;
    float * _arg9;
    float * _arg10;
    int  _arg11;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 12) || (items > 12)) 
        croak("Usage: five_arg(width,height,filename,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,dataset3,dataset4,dataset5,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"longPtr")) {
        croak("Type error in argument 4 of five_arg. Expected longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"charPtrPtr")) {
        croak("Type error in argument 6 of five_arg. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of five_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of five_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of five_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(9),(void **) &_arg9,"floatPtr")) {
        croak("Type error in argument 10 of five_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(10),(void **) &_arg10,"floatPtr")) {
        croak("Type error in argument 11 of five_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg11 = (int )SvIV(ST(11));
    five_arg(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11);
    XSRETURN(argvi);
}

XS(_wrap_six_arg) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long * _arg3;
    int  _arg4;
    char ** _arg5;
    float * _arg6;
    float * _arg7;
    float * _arg8;
    float * _arg9;
    float * _arg10;
    float * _arg11;
    int  _arg12;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 13) || (items > 13)) 
        croak("Usage: six_arg(width,height,filename,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,dataset3,dataset4,dataset5,dataset6,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"longPtr")) {
        croak("Type error in argument 4 of six_arg. Expected longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"charPtrPtr")) {
        croak("Type error in argument 6 of six_arg. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of six_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of six_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of six_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(9),(void **) &_arg9,"floatPtr")) {
        croak("Type error in argument 10 of six_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(10),(void **) &_arg10,"floatPtr")) {
        croak("Type error in argument 11 of six_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(11),(void **) &_arg11,"floatPtr")) {
        croak("Type error in argument 12 of six_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg12 = (int )SvIV(ST(12));
    six_arg(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12);
    XSRETURN(argvi);
}

XS(_wrap_seven_arg) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long * _arg3;
    int  _arg4;
    char ** _arg5;
    float * _arg6;
    float * _arg7;
    float * _arg8;
    float * _arg9;
    float * _arg10;
    float * _arg11;
    float * _arg12;
    int  _arg13;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 14) || (items > 14)) 
        croak("Usage: seven_arg(width,height,filename,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,dataset3,dataset4,dataset5,dataset6,dataset7,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"longPtr")) {
        croak("Type error in argument 4 of seven_arg. Expected longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"charPtrPtr")) {
        croak("Type error in argument 6 of seven_arg. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of seven_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of seven_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of seven_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(9),(void **) &_arg9,"floatPtr")) {
        croak("Type error in argument 10 of seven_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(10),(void **) &_arg10,"floatPtr")) {
        croak("Type error in argument 11 of seven_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(11),(void **) &_arg11,"floatPtr")) {
        croak("Type error in argument 12 of seven_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(12),(void **) &_arg12,"floatPtr")) {
        croak("Type error in argument 13 of seven_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg13 = (int )SvIV(ST(13));
    seven_arg(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12,_arg13);
    XSRETURN(argvi);
}

XS(_wrap_eight_arg) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long * _arg3;
    int  _arg4;
    char ** _arg5;
    float * _arg6;
    float * _arg7;
    float * _arg8;
    float * _arg9;
    float * _arg10;
    float * _arg11;
    float * _arg12;
    float * _arg13;
    int  _arg14;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 15) || (items > 15)) 
        croak("Usage: eight_arg(width,height,filename,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,dataset3,dataset4,dataset5,dataset6,dataset7,dataset8,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"longPtr")) {
        croak("Type error in argument 4 of eight_arg. Expected longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"charPtrPtr")) {
        croak("Type error in argument 6 of eight_arg. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of eight_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of eight_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of eight_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(9),(void **) &_arg9,"floatPtr")) {
        croak("Type error in argument 10 of eight_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(10),(void **) &_arg10,"floatPtr")) {
        croak("Type error in argument 11 of eight_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(11),(void **) &_arg11,"floatPtr")) {
        croak("Type error in argument 12 of eight_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(12),(void **) &_arg12,"floatPtr")) {
        croak("Type error in argument 13 of eight_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(13),(void **) &_arg13,"floatPtr")) {
        croak("Type error in argument 14 of eight_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg14 = (int )SvIV(ST(14));
    eight_arg(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12,_arg13,_arg14);
    XSRETURN(argvi);
}

XS(_wrap_nine_arg) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long * _arg3;
    int  _arg4;
    char ** _arg5;
    float * _arg6;
    float * _arg7;
    float * _arg8;
    float * _arg9;
    float * _arg10;
    float * _arg11;
    float * _arg12;
    float * _arg13;
    float * _arg14;
    int  _arg15;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 16) || (items > 16)) 
        croak("Usage: nine_arg(width,height,filename,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,dataset3,dataset4,dataset5,dataset6,dataset7,dataset8,dataset9,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"longPtr")) {
        croak("Type error in argument 4 of nine_arg. Expected longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"charPtrPtr")) {
        croak("Type error in argument 6 of nine_arg. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of nine_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of nine_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of nine_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(9),(void **) &_arg9,"floatPtr")) {
        croak("Type error in argument 10 of nine_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(10),(void **) &_arg10,"floatPtr")) {
        croak("Type error in argument 11 of nine_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(11),(void **) &_arg11,"floatPtr")) {
        croak("Type error in argument 12 of nine_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(12),(void **) &_arg12,"floatPtr")) {
        croak("Type error in argument 13 of nine_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(13),(void **) &_arg13,"floatPtr")) {
        croak("Type error in argument 14 of nine_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(14),(void **) &_arg14,"floatPtr")) {
        croak("Type error in argument 15 of nine_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg15 = (int )SvIV(ST(15));
    nine_arg(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12,_arg13,_arg14,_arg15);
    XSRETURN(argvi);
}

XS(_wrap_ten_arg) {

    int  _arg0;
    int  _arg1;
    char * _arg2;
    long * _arg3;
    int  _arg4;
    char ** _arg5;
    float * _arg6;
    float * _arg7;
    float * _arg8;
    float * _arg9;
    float * _arg10;
    float * _arg11;
    float * _arg12;
    float * _arg13;
    float * _arg14;
    float * _arg15;
    int  _arg16;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 17) || (items > 17)) 
        croak("Usage: ten_arg(width,height,filename,perl_GDC_SetColor,numpoints,labels,dataset1,dataset2,dataset3,dataset4,dataset5,dataset6,dataset7,dataset8,dataset9,dataset10,perl_type);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"longPtr")) {
        croak("Type error in argument 4 of ten_arg. Expected longPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    if (SWIG_GetPtr(ST(5),(void **) &_arg5,"charPtrPtr")) {
        croak("Type error in argument 6 of ten_arg. Expected charPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(6),(void **) &_arg6,"floatPtr")) {
        croak("Type error in argument 7 of ten_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(7),(void **) &_arg7,"floatPtr")) {
        croak("Type error in argument 8 of ten_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(8),(void **) &_arg8,"floatPtr")) {
        croak("Type error in argument 9 of ten_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(9),(void **) &_arg9,"floatPtr")) {
        croak("Type error in argument 10 of ten_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(10),(void **) &_arg10,"floatPtr")) {
        croak("Type error in argument 11 of ten_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(11),(void **) &_arg11,"floatPtr")) {
        croak("Type error in argument 12 of ten_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(12),(void **) &_arg12,"floatPtr")) {
        croak("Type error in argument 13 of ten_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(13),(void **) &_arg13,"floatPtr")) {
        croak("Type error in argument 14 of ten_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(14),(void **) &_arg14,"floatPtr")) {
        croak("Type error in argument 15 of ten_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(15),(void **) &_arg15,"floatPtr")) {
        croak("Type error in argument 16 of ten_arg. Expected floatPtr.");
        XSRETURN(1);
    }
    _arg16 = (int )SvIV(ST(16));
    ten_arg(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7,_arg8,_arg9,_arg10,_arg11,_arg12,_arg13,_arg14,_arg15,_arg16);
    XSRETURN(argvi);
}

XS(_wrap_perl5_gdchart_var_init) {
    dXSARGS;
    SV *sv;
    cv = cv; items = items;
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(boot_gdchart) {
	 dXSARGS;
	 char *file = __FILE__;
	 cv = cv; items = items;
	 newXS("gdchart::var_gdchart_init", _wrap_perl5_gdchart_var_init, file);
	 newXS("gdchart::ptrcast", _wrap_ptrcast, file);
	 newXS("gdchart::ptrvalue", _wrap_ptrvalue, file);
	 newXS("gdchart::ptrset", _wrap_ptrset, file);
	 newXS("gdchart::ptrcreate", _wrap_ptrcreate, file);
	 newXS("gdchart::ptrfree", _wrap_ptrfree, file);
	 newXS("gdchart::ptradd", _wrap_ptradd, file);
	 newXS("gdchart::ptrmap", _wrap_ptrmap, file);
	 newXS("gdchart::set_vars", _wrap_set_vars, file);
	 newXS("gdchart::annotate", _wrap_annotate, file);
	 newXS("gdchart::single_arg", _wrap_single_arg, file);
	 newXS("gdchart::set_pievars", _wrap_set_pievars, file);
	 newXS("gdchart::double_arg", _wrap_double_arg, file);
	 newXS("gdchart::combo", _wrap_combo, file);
	 newXS("gdchart::triple_arg", _wrap_triple_arg, file);
	 newXS("gdchart::hiloclose_wrap", _wrap_hiloclose_wrap, file);
	 newXS("gdchart::combo_hiloclose_wrap", _wrap_combo_hiloclose_wrap, file);
	 newXS("gdchart::gd_pie_graph", _wrap_gd_pie_graph, file);
	 newXS("gdchart::four_arg", _wrap_four_arg, file);
	 newXS("gdchart::five_arg", _wrap_five_arg, file);
	 newXS("gdchart::six_arg", _wrap_six_arg, file);
	 newXS("gdchart::seven_arg", _wrap_seven_arg, file);
	 newXS("gdchart::eight_arg", _wrap_eight_arg, file);
	 newXS("gdchart::nine_arg", _wrap_nine_arg, file);
	 newXS("gdchart::ten_arg", _wrap_ten_arg, file);
/*
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
 */
	 SWIG_RegisterMapping("unsigned short","short",0);
	 SWIG_RegisterMapping("long","unsigned long",0);
	 SWIG_RegisterMapping("long","signed long",0);
	 SWIG_RegisterMapping("signed short","short",0);
	 SWIG_RegisterMapping("signed int","int",0);
	 SWIG_RegisterMapping("short","unsigned short",0);
	 SWIG_RegisterMapping("short","signed short",0);
	 SWIG_RegisterMapping("unsigned long","long",0);
	 SWIG_RegisterMapping("int","unsigned int",0);
	 SWIG_RegisterMapping("int","signed int",0);
	 SWIG_RegisterMapping("unsigned int","int",0);
	 SWIG_RegisterMapping("signed long","long",0);
	 ST(0) = &sv_yes;
	 XSRETURN(1);
}
