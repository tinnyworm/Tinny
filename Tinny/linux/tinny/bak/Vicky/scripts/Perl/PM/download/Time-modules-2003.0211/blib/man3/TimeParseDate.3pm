.\" Automatically generated by Pod::Man version 1.02
.\" Mon Jun 16 19:01:26 2003
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Time::ParseDate 3"
.TH Time::ParseDate 3 "perl v5.6.0" "2003-06-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Time::ParseDate \*(-- date parsing both relative and absolute
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&        use Time::ParseDate;
\&        $seconds_since_jan1_1970 = parsedate("12/11/94 2pm", NO_RELATIVE => 1)
\&        $seconds_since_jan1_1970 = parsedate("12/11/94 2pm", %options)
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Date parsing can also use options.  The options are as follows:
.PP
.Vb 15
\&        FUZZY   -> it's okay not to parse the entire date string
\&        NOW     -> the "current" time for relative times (defaults to time())
\&        ZONE    -> local timezone (defaults to $ENV{TZ})
\&        WHOLE   -> the whole input string must be parsed
\&        GMT     -> input time is assumed to be GMT, not localtime
\&        UK      -> prefer UK style dates (dd/mm over mm/dd)
\&        DATE_REQUIRED -> do not default the date
\&        TIME_REQUIRED -> do not default the time
\&        NO_RELATIVE -> input time is not relative to NOW
\&        TIMEFIRST -> try parsing time before date [not default]
\&        PREFER_PAST -> when year or day of week is ambigueous, assume past
\&        PREFER_FUTURE -> when year or day of week is ambigueous, assume future
\&        SUBSECOND -> parse fraction seconds
\&        VALIDATE -> only accept normal values for HHMMSS, YYMMDD.  Otherwise
\&                days like -1 might give the last day of the previous month.
.Ve
.SH "DATE FORMATS RECOGNIZED"
.IX Header "DATE FORMATS RECOGNIZED"
.Sh "Absolute date formats"
.IX Subsection "Absolute date formats"
.Vb 18
\&        Dow, dd Mon yy
\&        Dow, dd Mon yyyy
\&        Dow, dd Mon
\&        dd Mon yy
\&        dd Mon yyyy
\&        Month day{st,nd,rd,th}, year
\&        Month day{st,nd,rd,th}
\&        Mon dd yyyy
\&        yyyy/mm/dd
\&        yyyy/mm
\&        mm/dd/yy
\&        mm/dd/yyyy
\&        mm/yy
\&        yy/mm      (only if year > 12, or > 31 if UK)
\&        yy/mm/dd   (only if year > 12 and day < 32, or year > 31 if UK)
\&        dd/mm/yy   (only if UK, or an invalid mm/dd/yy or yy/mm/dd)
\&        dd/mm/yyyy (only if UK, or an invalid mm/dd/yyyy)
\&        dd/mm      (only if UK, or an invalid mm/dd)
.Ve
.Sh "Relative date formats:"
.IX Subsection "Relative date formats:"
.Vb 18
\&        count "days"
\&        count "weeks"
\&        count "months"
\&        count "years"
\&        Dow "after next"
\&        Dow                     (requires PREFER_PAST or PREFER_FUTURE)
\&        "next" Dow
\&        "tomorrow"
\&        "today"
\&        "yesterday"
\&        "last" dow
\&        "last week"
\&        "now"
\&        "now" "+" count units
\&        "now" "-" count units
\&        "+" count units
\&        "-" count units
\&        count units "ago"
.Ve
.Sh "Absolute time formats:"
.IX Subsection "Absolute time formats:"
.Vb 7
\&        hh:mm:ss[.ddd] 
\&        hh:mm 
\&        hh:mm[AP]M
\&        hh[AP]M
\&        hhmmss[[AP]M] 
\&        "noon"
\&        "midnight"
.Ve
.Sh "Relative time formats:"
.IX Subsection "Relative time formats:"
.Vb 8
\&        count "minuts"
\&        count "seconds"
\&        count "hours"
\&        "+" count units
\&        "+" count
\&        "-" count units
\&        "-" count
\&        count units "ago"
.Ve
.Sh "Timezone formats:"
.IX Subsection "Timezone formats:"
.Vb 4
\&        [+-]dddd
\&        GMT[+-]d+
\&        [+-]dddd (TZN)
\&        TZN
.Ve
.Sh "Special formats:"
.IX Subsection "Special formats:"
.Vb 2
\&        [ d]d/Mon/yyyy:hh:mm:ss [[+-]dddd]
\&        yy/mm/dd.hh:mm
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module recognizes the above date/time formats.   Usually a
date and a time are specified.  There are numerous options for 
controlling what is recognized and what is not.
.PP
The return code is always the time in seconds since January 1st, 1970
or undef if it was unable to parse the time.
.PP
If a timezone is specified it must be after the time.  Year specifications
can be tacked onto the end of absolute times.
.PP
If \f(CW\*(C`parsedate()\*(C'\fR is called from array contect, then it will return two
elements.  On sucessful parses, it will return the seconds and what 
remains of its input string.  On unsucessful parses, it will return
\&\f(CW\*(C`undef\*(C'\fR and an error string.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 8
\&        $seconds = parsedate("Mon Jan  2 04:24:27 1995");
\&        $seconds = parsedate("Tue Apr 4 00:22:12 PDT 1995");
\&        $seconds = parsedate("04.04.95 00:22", ZONE => PDT);
\&        $seconds = parsedate("Jan 1 1999 11:23:34.578", SUBSECOND => 1);
\&        $seconds = parsedate("122212 950404", ZONE => PDT, TIMEFIRST => 1);
\&        $seconds = parsedate("+3 secs", NOW => 796978800);
\&        $seconds = parsedate("2 months", NOW => 796720932);
\&        $seconds = parsedate("last Tuesday");
.Ve
.Vb 2
\&        ($seconds, $remaining) = parsedate("today is the day");
\&        ($seconds, $error) = parsedate("today is", WHOLE=>1);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
David Muir Sharnoff <muir@idiom.com>.  
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 1996\-1999 David Muir Sharnoff.  License hereby
granted for anyone to use, modify or redistribute this module at
their own risk.  Please feed useful changes back to muir@idiom.com.
