.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Exception 3"
.TH Exception 3 "2004-04-01" "perl v5.8.2" "User Contributed Perl Documentation"
.SH "NAME"
.Vb 1
\&    Exception - structured exception handling for Perl
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Exception qw(:all);
.Ve
.PP
.Vb 2
\&    Exception->debugLevel(DEBUG_STACK);
\&    my $err=new Exception 'id';
.Ve
.PP
.Vb 15
\&    try {
\&      $err->raise('error text');
\&      die 'dead';
\&    }
\&    when $err, except {
\&        my $error=shift;
\&        $error->confess;
\&      }
\&    when 'die', reraise
\&    except {
\&        shift->croak;
\&      }
\&    finally {
\&        print STDERR "Tidying up\en";
\&      };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module fulfils two needs; it converts all errors raised by \fIdie\fR
to exception objects which may contain stack trace information and it
implements a structured exception handling syntax as summarised above.
.Sh "What You Get Just by Loading the Module"
.IX Subsection "What You Get Just by Loading the Module"
\&\fBException\fR installs a \f(CW$SIG{_\|_DIE_\|_}\fR handler that converts text
passed to \fIdie\fR into an exception object. Stringification for the object
is mapped onto the stringify method so, by default, Perl
will simply print the error text on to \fI\s-1STDERR\s0\fR on termination.
.Sh "Structured Exception Handling"
.IX Subsection "Structured Exception Handling"
\&\fBException\fR allows you to structure your exception handling; code that
can directly or indirectly raise an exception is enclosed in a
try block, followed by
except blocks that can handle specific exceptions or
act as a catch-all handler for any exceptions not otherwise dealt with.
Exceptions may be propagated back to outer contexts with the possibility of
adding extra information to the exception, and a finally
block can also be specified, containing tidy-up code that will be called whether
or not an exception is raised.
.PP
Exception handling blocks can be tied to specific exceptions by id, by
exception object or by regexp match against error text. The default
exception display code can be augmented or replaced by user code.
.Sh "Stack Tracing"
.IX Subsection "Stack Tracing"
\&\fBException\fR can be persuaded to capture and display a stack trace
globally, by exception object or explicitly when an exception is raised.
You can capture just the context at which the exception is raised, a full
stack trace or an absolutely full stack trace including calls within the
\&\fBException\fR module itself (and, if appropriate, within mod_perl).
.SH "EXCEPTION OBJECTS"
.IX Header "EXCEPTION OBJECTS"
\&\fBException\fR will create an exception object when it traps a \fIdie\fR. More
flexibly, user-created exception objects can be raised with the raise
method.
.PP
Each exception object has an id; a text string that is set when the object
is created (and that can be changed using the id method thereafter).
\&\fIdie\fR exceptions have the id 'die', anonymous exceptions created at
raise time have an empty id. The exception id is set initially by a
parameter to the exception constructor:
.PP
.Vb 1
\&  my $err=new Exception 'id';
.Ve
.PP
Exceptions are raised by the raise method:
.PP
.Vb 1
\&  $err->raise('error text');
.Ve
.PP
or:
.PP
.Vb 1
\&  Exception->raise('text');
.Ve
.PP
for an anonymous exception.
.SH "STRUCTURED EXCEPTION HANDLING"
.IX Header "STRUCTURED EXCEPTION HANDLING"
Code to be protected by \fBException\fR is enclosed in a \f(CW\*(C`try {}\*(C'\fR block. Any
\&\fIdie\fR or raise event is captured; what happens next is
up to you. In any case, you need to import the routines that implement the
exception structuring:
.PP
.Vb 1
\&  use Exception qw(:try);
.Ve
.PP
is the incantation. Either that or one of \f(CW\*(C`qw(:stack)\*(C'\fR, \f(CW\*(C`qw(:debug)\*(C'\fR
or \f(CW\*(C`qw(:all)\*(C'\fR if you need stack frame, debug or both facilities as
well.
.Sh "Default Behaviour"
.IX Subsection "Default Behaviour"
If no exception handling code is present, the exception is reraised and
thus passed to the calling block; this is, of course, exactly what would
happen if \fItry\fR wasn't present at all. More usefully, the same will happen
for any exceptions raised that aren't matched by any of the supplied
exception blocks.
.PP
If no user-supplied exception handler gets called at all, Perl will
display the exception by stringifying it and terminate the program.
.Sh "Trapping Exceptions"
.IX Subsection "Trapping Exceptions"
\&\fIexcept\fR blocks match all or some exceptions. You can define as many as you
like; all blocks that specifically match an exception are called (unless an
earlier \fIexcept\fR block raises an exception itself), default blocks are only
executed for otherwise unmatched exceptions.
.PP
In either case, the \fIexcept\fR block is passed two parameters: the exception
object and the current return value for the entire \fItry\fR construct if it
has been set.
.PP
Use the \fIwhen\fR clause to match exceptions against \fIexcept\fR blocks:
.PP
.Vb 1
\&  try {<code>} when <condition>, except {<handler>};
.Ve
.PP
Conditions may be text strings, matching the id of an exception, regexp
refs, matching the text of an exception, or exception objects, matching
the given exception object or clones thereof. Multiple conditions may be
specified in an array ref; the \fIexcept\fR block will apply if any of the
conditions match.
.PP
For example:
.PP
.Vb 1
\&  my $err=new Exception 'foo';
.Ve
.PP
.Vb 6
\&  try {
\&    $err->raise('bar');
\&  }
\&  when ['foo', qr/bar/, $err], except {
\&      shift->croak;
\&    };
.Ve
.PP
will match on all three conditions.
.Sh "Reraising Exceptions"
.IX Subsection "Reraising Exceptions"
Exceptions can be passed to a calling context by reraising them using the
\&\fIreraise\fR clause. \fIreraise\fR can be tied to specific exceptions using
\&\fIwhen\fR exactly as for \fIexcept\fR.
.PP
For example:
.PP
.Vb 7
\&  try {
\&    <code>
\&  }
\&  when 'die', reraise
\&  except {
\&      <other exceptions>
\&    };
.Ve
.PP
would pass exceptions raised by \fIdie\fR to the calling routine.
.Sh "Transforming Exceptions"
.IX Subsection "Transforming Exceptions"
It is sometimes useful to change the id of an exception. For example, a
module might want to identify all exceptions raised within it as its own,
even if they were originally raised in another module that it called. The
as method performs this function:
.PP
.Vb 1
\&  my $myErr=new Exception 'myModule';
.Ve
.PP
.Vb 8
\&  try {
\&    <calls to other code that might raise exceptions>
\&    <local code that might raise $myErr exceptions>
\&  }
\&  when $myErr, reraise
\&  except {
\&      shift->as($myErr)->raise('extra text');
\&    };
.Ve
.PP
This will pass locally raised exception straight on; other exceptions will
be converted to \f(CW$myErr\fR exceptions first. The error text parameter to
the raise can be omitted: if so, the original error text is passed on
unchanged. Adding extra text can however be useful in providing extra
contextual information for the exception.
.PP
Using an exception object as the parameter to as in this way replaces
the \fIid\fR, \fIdebugLevel\fR and \fIconfessor\fR properties of the original
exception. as can also be passed a text string if only the \fIid\fR of the
exception needs changing.
.Sh "Finalisation Blocks"
.IX Subsection "Finalisation Blocks"
One or more \fIfinally\fR blocks can be included. These will \fBall\fR be executed
\&\fBalways\fR regardless of exceptions raised, trapped or reraised and can
contain any tidy-up code required \- any exception raised in an \fIexcept\fR
block, reraised or not handled at all will be raised \fBafter\fR all \fIfinally\fR
blocks have been executed:
.PP
.Vb 9
\&  try {
\&    <code>
\&  }
\&  except {
\&      <exception handling>
\&    }
\&  finally {
\&      <housekeeping code>
\&    }
.Ve
.PP
The \fIfinally\fR blocks are passed two parameters, the exception (if any) and
the current return value (if any) in the same way as for \fIexcept\fR blocks.
.Sh "Return Values"
.IX Subsection "Return Values"
\&\fItry\fR constructs can return a (scalar) value; this is the value returned
by either the \fItry\fR block itself or by the last executed \fIexcept\fR block if
any exception occurs, passed though any \fIfinally\fR blocks present.
.PP
For example:
.PP
.Vb 13
\&  my $value=try {
\&    <code>
\&    return 1;
\&  }
\&  except {
\&      <code>
\&      return 0;
\&    }
\&  finally {
\&      my ($error, $retval)=@_;
\&      <code>
\&      return $retval;
\&    }
.Ve
.PP
will set \f(CW$value\fR to \f(CW1\fR or \f(CW0\fR depending on whether an exception has
occured. Note the way that the return value is passed through the
\&\fIfinally\fR block.
.SH "STACK TRACING"
.IX Header "STACK TRACING"
\&\fBException\fR can be persuaded to capture and display a stack trace by
any one of four methods:
.IP "1." 4
by setting the environment variable \f(CW\*(C`_DEBUG_LEVEL\*(C'\fR before starting your
Perl script.
.IP "2." 4
by setting the package default with \f(CW\*(C`Exception\->debugLevel(DEBUG_STACK)\*(C'\fR.
.IP "3." 4
by setting the debug level explicitly in an error object when you create
it:
.Sp
.Vb 2
\&  my $err=new Exception 'foo';
\&  $err->debugLevel(DEBUG_CONTEXT);
.Ve
.IP "4." 4
by setting the debug level when you raise the exception:
.Sp
.Vb 1
\&  $err->raise("failed: $!", {DEBUGLEVEL=>DEBUG_ALL});
.Ve
.PP
Each of these will override preceding methods. The default default is no
stack capture at all.
.PP
The debug level can be set to:
.IP "\s-1DEBUG_NONE:\s0" 4
.IX Item "DEBUG_NONE:"
no stack trace is stored.
.IP "\s-1DEBUG_CONTEXT:\s0" 4
.IX Item "DEBUG_CONTEXT:"
only the location at which the exception was raised is stored.
.IP "\s-1DEBUG_STACK:\s0" 4
.IX Item "DEBUG_STACK:"
a full stack trace, excluding calls within \fBException\fR, is stored.
.IP "\s-1DEBUG_ALL:\s0" 4
.IX Item "DEBUG_ALL:"
a full stack trace, \fBincluding\fR calls within \fBException\fR, is stored.
.PP
You need to import these constants to use them:
.PP
.Vb 2
\&  use Exception qw(:debug);
\&  use Exception qw(:all);
.Ve
.PP
will do the trick.
.PP
Note that these controls apply to when the exception is raised \- the
display routines will always print or return whatever stack information
is available to them.
.SH "EXCEPTION OBJECT METHODS"
.IX Header "EXCEPTION OBJECT METHODS"
.Sh "new"
.IX Subsection "new"
.Vb 2
\&  my $err=new Exception 'id', 'error text';
\&  my $new=$err->new('id2', 'error text');
.Ve
.PP
This method either creates a new exception from scratch or clones an
existing exception.
.PP
The first parameter is an exception id that can be used to identify either
individual exceptions or classes of exceptions. The optional second
parameter sets the text of the exception, this can be added to when the
exception is raised. The default is no text.
.Sh "raise"
.IX Subsection "raise"
.Vb 2
\&  open FH, "<filename"
\&    or $err->raise("can't read filename: $!");
.Ve
.PP
Raise an exception. That's it really. If \fIraise\fR is applied to an existing
exception object as above, the text supplied is added to any pre-existing
text in the object. Anonymous exceptions can also be raised:
.PP
.Vb 1
\&  Exception->raise('bang');
.Ve
.PP
but the use of predeclared exception objects is encouraged.
.Sh "as"
.IX Subsection "as"
.Vb 2
\&  $err1->as($err2);
\&  $err1->as('new id');
.Ve
.PP
Transform an exception object either from another template exception, which
will change the object's id, debug level and confessor, or by name, which
will just change the id of the exception.
.PP
\&\fIas\fR returns the exception object, so a further method (typically raise)
may be applied in the same statement:
.PP
.Vb 1
\&  $err1->as('foo')->raise;
.Ve
.Sh "stringify"
.IX Subsection "stringify"
.Vb 2
\&  my $text=$err->stringify;
\&  my $text=$err->stringify(1);
.Ve
.PP
Return the text and any saved stack trace of an exception object. the optional
parameter is a bitmask,
.Sh "stack"
.IX Subsection "stack"
.Vb 1
\&  my $stack=$err->stack;
.Ve
.PP
Return the stack trace data (if any) for an exception. The stack is returned
as a reference to an array of stack frames; each stack frame being a reference
to an array of data as returned by \fIcaller\fR. The stack frame elements can be
indexed symbolically as \fI\s-1FRAME_PACKAGE\s0\fR, \fI\s-1FRAME_FILE\s0\fR, \fI\s-1FRAME_LINE\s0\fR,
\&\fI\s-1FRAME_SUBNAME\s0\fR, \fI\s-1FRAME_HASARGS\s0\fR and \fI\s-1FRAME_WANTARRAY\s0\fR. \fI\s-1FRAME_LAST\s0\fR is
defined as the index of the last element of the frame array for convenience.
.PP
To use these names, you need to import their definitions:
.PP
.Vb 2
\&  use Exception qw(:stack);
\&  use Exception qw(:all);
.Ve
.PP
will do what you want.
.Sh "text"
.IX Subsection "text"
.Vb 4
\&  my $text=$err->text;
\&  my $defaultText=Exception->text;
\&  my $old=$err->text($new);
\&  my $oldDefault=Exception->text($new);
.Ve
.PP
Get or set the text of an exception. The routines all return a reference to
the array of error text strings held in the \fBException\fR object before the
call. If \fItext\fR is passed a text string, that text is added to the end of the
array; if \fItext\fR is passed a reference to an array of strings, the array is
\&\fBreplaced\fR by the one given.
.PP
An exception also gains a line every time it is raised with a text parameter.
Actually, to be precise, raise creates a new exception object with the
extra line, but that's the sort of implementation detail you don't need to
know, unless of course you want to...
.Sh "debugLevel"
.IX Subsection "debugLevel"
.Vb 4
\&  my $level=$err->debugLevel;
\&  my $defaultLevel=Exception->debugLevel;
\&  my $old=$err->debugLevel($new);
\&  my $oldDefault=Exception->debugLevel($newDefault);
.Ve
.PP
Get or set the stack trace level for an exception of object or the package
default. See the section above.
.Sh "confessor"
.IX Subsection "confessor"
.Vb 4
\&  my $code=$err->confessor;
\&  my $defaultCode=Exception->confessor;
\&  my $old=$err->confessor($new);
\&  my $oldDefault=Exception->confessor($new);
.Ve
.PP
Get or set code to display an exception. The routines all return a reference
to an array of coderefs; the routines are called in sequence when an
exception's confess or croak methods are invoked.
.PP
If \fIconfessor\fR is passed a coderef, the code is added to the end of the
array (the routines are actually called last to first); if \fIconfessor\fR is
passed a reference to an array of coderefs, the array is \fBreplaced\fR by the
one given. As a special case, if the array given is empty, the set of confessor
routines is reset to the default.
.PP
A useful example of a confessor would be code that printed an exception on
\&\fI\s-1STDOUT\s0\fR instead of \fI\s-1STDERR\s0\fR which, used in conjunction with a
stringifier that generated \s-1HTML\s0, could be used within \s-1CGI\s0
scripts.
.PP
A confessor routine is passed two parameters when called: the exception
object and a \fIquiet\fR flag; if this is non\-zero, the routine is expected not
to produce any output. The routine should return the new value of the flag:
\&\f(CW0\fR, \f(CW1\fR or \f(CW\*(C`\-1\*(C'\fR, the last telling \fBException\fR to not call any further
display routines at all.
.PP
As a trivial example, here's the default routine provided:
.PP
.Vb 5
\&  sub _confess($$) {
\&    my ($error, $quiet)=@_;
\&    print STDERR $error->stringify unless $quiet;
\&    $quiet
\&  }
.Ve
.Sh "stringifier"
.IX Subsection "stringifier"
.Vb 4
\&  my $code=$err->stringifier;
\&  my $defaultCode=Exception->stringifier;
\&  my $old=$err->stringifier($new);
\&  my $oldDefault=Exception->stringifier($new);
.Ve
.PP
Get or set the code to stringify an exception object. This code will be called
by the stringification overloading and by the stringify and
default confess methods (the latter is also called by the
<croak method).
.PP
Your stringifier routine takes two parameters: the exception object and the
option parameter passed to the stringify method; import
\&\fI:stringify\fR to get the symbolic bit names into your code:
.IP "\s-1STRINGIFY_NOSTACK\s0" 4
.IX Item "STRINGIFY_NOSTACK"
return just the text even if a stack trace is available.
.IP "\s-1STRINGIFY_EXITCATCH\s0" 4
.IX Item "STRINGIFY_EXITCATCH"
this bit shouldn't be set in user code; it will be set for you for mod_perl
scripts (and \s-1CGI\s0 scripts if you've set checkCGI) if your script
is exiting with an uncaught exception.
.Sh "id"
.IX Subsection "id"
.Vb 4
\&  my $id=$err->id;
\&  my $defaultId=Exception->id;
\&  my $old=$err->id($new);
\&  my $oldDefault=Exception->id($new);
.Ve
.PP
Get or set the id of an exception, or of the package default used for
anonymous exceptions. Exception ids can be of any scalar type \- \fBException\fR
uses text strings for those it generates internally ('die' for exceptions
raised from \fIdie\fR and, by default, '' for anonymous exceptions) \- but you
can even use object references if you can think of something useful to do
with them, with the proviso that \fIwhen\fR uses a simple \f(CW\*(C`eq\*(C'\fR test to match
them; you'll need to overload \f(CW\*(C`eq\*(C'\fR for your objects if you want anything
clever to happen.
.Sh "exitcode"
.IX Subsection "exitcode"
.Vb 4
\&  my $exitcode=$err->exitcode;
\&  my $defaultExitcode=Exception->exitcode;
\&  my $old=$err->exitcode($new);
\&  my $oldDefault=Exception->exitcode($new);
.Ve
.PP
Get or set the exit code returned to the \s-1OS\s0 by croak. This defaults to
\&\f(CW1\fR.
.Sh "confess"
.IX Subsection "confess"
.Vb 1
\&  $err->confess;
.Ve
.PP
Display the exception using the list of confessor routines it
contains. By default, this will print the stringified exception
on \fI\s-1STDERR\s0\fR.
.Sh "croak"
.IX Subsection "croak"
.Vb 2
\&  $err->croak;
\&  $err->croak($exitCode);
.Ve
.PP
Call the exception's confess method and terminate. If no exit code is
supplied, exit with the exception's exit code as set by the exitcode
method.
.Sh "registerDefault"
.IX Subsection "registerDefault"
.Vb 4
\&  package MyError;
\&  @ISA=qw(Exception);
\&  use Exception qw(:all);
\&  BEGIN {MyError->registerDefault}
.Ve
.PP
This package method reblesses the default and die exception objects as being
members of a subclass. This is intended for subclasses that reimplement the
stringify method for a particular environment (typically a \s-1CGI\s0
script) so that the default handling, in the absence of a caught try block, for
the inbuilt anonymous and die exception objects uses the subclassed
stringify to render the exception.
.PP
Clearly, the last package that invokes this method gets the objects.
.SH "COMPATIBILTY"
.IX Header "COMPATIBILTY"
Code written prior to version 1.5 that calls the \fItext\fR method will need
rewriting:
.PP
.Vb 1
\& 1.4 and earlier                         1.5 and later
.Ve
.PP
.Vb 3
\& scalar $err->text or $err->text(0)      => $err->stringify(1)
\&        $err->text(1)                    => join "\en", @{$err->text}
\&        $err->text(2)                    => $err->stringify or "$err"
.Ve
.PP
.Vb 2
\& list   $err->text or $err->text(0 or 1) => @{$err->text}
\&        $err->text(2)                    => (@{$err->text}, $err->stack)
.Ve
.SH "BUGS"
.IX Header "BUGS"
The module can interact in unpredictable ways with other code that messes
with \f(CW$SIG{_\|_DIE_\|_}\fR. It does its best to cope by keeping and propagating
to any \fIdie\fR handler that is defined when the module is initialised, but
no guarantees of sane operation are given.
.PP
\&\fIfinally\fR blocks are always executed, even if an exception is reraised or
an exception is raised in an \fIexcept\fR block. No problem there, but this
raises the question of what to do if \fBanother\fR exception is raised in the
\&\fIfinally\fR block. At present \fBException\fR merges the the second exception
into the first before reraising it, which is probably the best it can do,
so this probably isn't a bug after all. Whatever.
.PP
Need More Tests.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pete Jordan <pete@skydancer.org.uk>
http://www.skydancer.org.uk/
